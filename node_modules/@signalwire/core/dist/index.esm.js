var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/utils/constants.ts
var DEFAULT_HOST = "wss://relay.signalwire.com";
var EVENT_NAMESPACE_DIVIDER = ":";
var LOCAL_EVENT_PREFIX = "__local__";
var SYNTHETIC_EVENT_PREFIX = "__synthetic__";
var PRODUCT_PREFIX_VIDEO = "video";
var PRODUCT_PREFIX_CHAT = "chat";
var PRODUCT_PREFIX_PUBSUB = "chat";
var GLOBAL_VIDEO_EVENTS = ["room.started", "room.ended"];
var INTERNAL_GLOBAL_VIDEO_EVENTS = GLOBAL_VIDEO_EVENTS.map(
  (event) => `${PRODUCT_PREFIX_VIDEO}.${event}`
);
var SYMBOL_EXECUTE_CONNECTION_CLOSED = Symbol.for(
  "sw-execute-connection-closed"
);
var SYMBOL_EXECUTE_TIMEOUT = Symbol.for("sw-execute-timeout");
var SYMBOL_CONNECT_ERROR = Symbol.for("sw-connect-error");

// src/utils/logger.ts
import log from "loglevel";
var datetime = () => (/* @__PURE__ */ new Date()).toISOString();
var defaultLogger = log.getLogger("signalwire");
var originalFactory = defaultLogger.methodFactory;
defaultLogger.methodFactory = (methodName, logLevel, loggerName) => {
  const rawMethod = originalFactory(methodName, logLevel, loggerName);
  return function(...args) {
    args.unshift(datetime(), "-");
    rawMethod.apply(void 0, args);
  };
};
var defaultLoggerLevel = (
  // @ts-ignore
  "development" === process.env.NODE_ENV ? defaultLogger.levels.DEBUG : defaultLogger.getLevel()
);
defaultLogger.setLevel(defaultLoggerLevel);
var userLogger;
var setLogger = (logger) => {
  userLogger = logger;
};
var debugOptions = {};
var setDebugOptions = (options) => {
  if (options == null) {
    debugOptions = {};
    return;
  }
  Object.assign(debugOptions, options);
};
var getLoggerInstance = () => {
  return userLogger != null ? userLogger : defaultLogger;
};
var shouldStringify = (payload) => {
  if ("method" in payload && payload.method === "signalwire.ping") {
    return false;
  }
  return true;
};
var wsTraffic = ({ type, payload }) => {
  const logger = getLoggerInstance();
  const { logWsTraffic } = debugOptions || {};
  if (!logWsTraffic) {
    return void 0;
  }
  const msg = shouldStringify(payload) ? JSON.stringify(payload, null, 2) : payload;
  return logger.info(`${type.toUpperCase()}: 
`, msg, "\n");
};
var getLogger = () => {
  const logger = getLoggerInstance();
  return new Proxy(logger, {
    get(target, prop, receiver) {
      if (prop === "wsTraffic") {
        return wsTraffic;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/utils/common.ts
var UPPERCASE_REGEX = /[A-Z]/g;
var fromCamelToSnakeCase = (value) => {
  return value.replace(UPPERCASE_REGEX, (letter) => {
    return `_${letter.toLowerCase()}`;
  });
};
var WEBRTC_EVENT_TYPES = [
  "webrtc.message"
  // 'webrtc.verto',
];
var isWebrtcEventType = (eventType) => {
  return WEBRTC_EVENT_TYPES.includes(eventType);
};

// src/utils/index.ts
import { v4 } from "uuid";

// src/utils/parseRPCResponse.ts
var parseRPCResponse = ({
  response,
  request
}) => {
  const { result = {}, error } = response;
  if (error) {
    return {
      error
    };
  }
  switch (request.method) {
    case "signalwire.connect":
      return { result };
    default:
      return parseResponse(response);
  }
};
var whitelistCodeRegex = /^2[0-9][0-9]$/;
var parseResponse = (response, nodeId) => {
  const { result = {}, error } = response;
  if (error) {
    return { error };
  }
  const { code, node_id, result: nestedResult = null } = result;
  if (code && !whitelistCodeRegex.test(code)) {
    return { error: result };
  }
  if (nestedResult === null) {
    if (nodeId) {
      result.node_id = nodeId;
    }
    return { result };
  }
  if (nestedResult) {
    if (nestedResult.jsonrpc) {
      return parseResponse(nestedResult, node_id);
    }
    return { result: nestedResult };
  }
  return { result };
};

// src/utils/toExternalJSON.ts
var toDateObject = (timestamp) => {
  if (typeof timestamp === "undefined") {
    return timestamp;
  }
  const date = new Date(timestamp * 1e3);
  if (isNaN(date.getTime())) {
    return timestamp;
  }
  return date;
};
var DEFAULT_OPTIONS = {
  /**
   * Properties coming from the server where their value will be
   * converted to camelCase
   */
  propsToUpdateValue: [
    "updated",
    "layers",
    "members",
    "recordings",
    "playbacks"
  ]
};
var isTimestampProperty = (prop) => {
  return prop.endsWith("At");
};
var toExternalJSON = (input, options = DEFAULT_OPTIONS) => {
  if ((input == null ? void 0 : input.__sw_symbol) || (input == null ? void 0 : input.__sw_proxy)) {
    return input;
  }
  return Object.entries(input).reduce((reducer, [key, value]) => {
    const prop = fromSnakeToCamelCase(key);
    const propType = typeof value;
    if (propType === "object" && value) {
      if (Array.isArray(value)) {
        if (options.propsToUpdateValue.includes(key)) {
          reducer[prop] = value.map((v) => {
            if (typeof v === "string") {
              return fromSnakeToCamelCase(v);
            }
            return toExternalJSON(v);
          });
        } else {
          reducer[prop] = value;
        }
      } else {
        reducer[prop] = toExternalJSON(value);
      }
    } else {
      if (isTimestampProperty(prop)) {
        reducer[prop] = toDateObject(value);
      } else {
        reducer[prop] = value;
      }
    }
    return reducer;
  }, {});
};
var fromSnakeToCamelCase = (input) => {
  if (!input.includes("_")) {
    return input;
  }
  return input.split("_").reduce((reducer, part, index) => {
    const fc = part.trim().charAt(0);
    const remainingChars = part.substr(1).toLowerCase();
    return `${reducer}${index === 0 ? fc.toLowerCase() : fc.toUpperCase()}${remainingChars}`;
  }, "");
};

// src/utils/toInternalEventName.ts
var toInternalEventName = ({
  event,
  namespace
}) => {
  if (typeof event === "string") {
    event = getNamespacedEvent({
      event,
      namespace
    });
    event = fromCamelToSnakeCase(event);
  }
  return event;
};
var getNamespacedEvent = ({
  namespace,
  event
}) => {
  if (!namespace || event.startsWith(namespace)) {
    return event;
  }
  return `${namespace}${EVENT_NAMESPACE_DIVIDER}${event}`;
};

// src/utils/toInternalAction.ts
var toInternalAction = (event) => {
  const { event_type, params, node_id } = event;
  if (event_type === "queuing.relay.tasks") {
    return {
      type: event_type,
      payload: event
    };
  }
  if (isWebrtcEventType(event_type) && (params == null ? void 0 : params.jsonrpc)) {
    const vertoRPC = params;
    if (vertoRPC.params) {
      vertoRPC.params.nodeId = node_id;
    }
    return {
      type: event_type,
      payload: vertoRPC
    };
  }
  return {
    type: event_type,
    payload: params
  };
};

// src/utils/toSnakeCaseKeys.ts
var toSnakeCaseKeys = (obj, transform = (value) => value, result = {}) => {
  if (Array.isArray(obj)) {
    result = obj.map((item, index) => {
      if (typeof item === "object") {
        return toSnakeCaseKeys(item, transform, result[index]);
      }
      return item;
    });
  } else {
    Object.keys(obj).forEach((key) => {
      const newKey = fromCamelToSnakeCase(key);
      if (obj[key] && typeof obj[key] === "object") {
        result[newKey] = toSnakeCaseKeys(obj[key], transform, result[newKey]);
      } else {
        result[newKey] = transform(obj[key]);
      }
    });
  }
  return result;
};

// src/utils/extendComponent.ts
var extendComponent = (klass, methods) => {
  Object.keys(methods).forEach((methodName) => {
    if (klass.prototype.hasOwnProperty(methodName)) {
      throw new Error(`[extendComponent] Duplicated method name: ${methodName}`);
    }
  });
  Object.defineProperties(klass.prototype, methods);
  return klass;
};

// src/utils/debounce.ts
function debounce(fn, wait2 = 0, callFirst) {
  let timeout = null;
  let debouncedFn = null;
  const clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  const flush = function() {
    const call4 = debouncedFn;
    clear();
    if (call4) {
      call4();
    }
  };
  const debounceWrapper = function() {
    if (!wait2) {
      return fn.apply(this, arguments);
    }
    const context = this;
    const args = arguments;
    const callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        const call4 = debouncedFn;
        debouncedFn = null;
        return call4 == null ? void 0 : call4();
      }
    }, wait2);
    if (callNow && debouncedFn) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}

// src/utils/SWCloseEvent.ts
var SWCloseEvent = class {
  constructor(type, options = {}) {
    this.type = type;
    __publicField(this, "code");
    __publicField(this, "reason");
    __publicField(this, "wasClean");
    this.code = options.code === void 0 ? 0 : options.code;
    this.reason = options.reason === void 0 ? "" : options.reason;
    this.wasClean = options.wasClean === void 0 ? false : options.wasClean;
  }
};

// src/utils/eventUtils.ts
var stripNamespacePrefix = (event, namespace) => {
  if (namespace && typeof namespace === "string") {
    const regex = new RegExp(`^${namespace}.`);
    return event.replace(regex, "");
  }
  const items = event.split(".");
  if (items.length > 1) {
    items.shift();
    return items.join(".");
  }
  return event;
};

// src/utils/asyncRetry.ts
var DEFAULT_MAX_RETRIES = 10;
var DEFAULT_INITIAL_DELAY = 100;
var DEFAULT_DELAY_VARIATION = 1;
var increasingDelay = ({
  delayLimit: upperDelayLimit = Number.MAX_SAFE_INTEGER,
  initialDelay = DEFAULT_INITIAL_DELAY,
  variation = DEFAULT_DELAY_VARIATION
}) => {
  if (initialDelay < 0 || upperDelayLimit < 0 || variation < 0) {
    throw new Error("No Negative Numbers");
  }
  if (initialDelay > upperDelayLimit) {
    throw new Error("initialDelay must be lte delayLimit");
  }
  let delay = Math.min(initialDelay, upperDelayLimit);
  return () => {
    if (delay === upperDelayLimit) {
      return upperDelayLimit;
    }
    const currentDelay = delay;
    delay = Math.min(delay + variation, upperDelayLimit);
    return currentDelay;
  };
};
var decreasingDelay = ({
  delayLimit: bottomDelayLimit = 0,
  initialDelay = DEFAULT_INITIAL_DELAY,
  variation = DEFAULT_DELAY_VARIATION
}) => {
  if (initialDelay < 0 || bottomDelayLimit < 0 || variation < 0) {
    throw new Error("No Negative Numbers");
  }
  if (initialDelay < bottomDelayLimit) {
    throw new Error("initialDelay must be gte delayLimit");
  }
  let delay = Math.max(initialDelay, bottomDelayLimit);
  return () => {
    if (delay === bottomDelayLimit) {
      return bottomDelayLimit;
    }
    const currentDelay = delay;
    delay = Math.max(delay - variation, bottomDelayLimit);
    return currentDelay;
  };
};
var constDelay = ({
  initialDelay = DEFAULT_INITIAL_DELAY
}) => {
  if (initialDelay < 0) {
    throw new Error("No Negative Numbers");
  }
  return () => initialDelay;
};
var asyncRetry = async ({
  asyncCallable,
  maxRetries: retries = DEFAULT_MAX_RETRIES,
  delayFn,
  validator,
  expectedErrorHandler
}) => {
  let remainingAttempts = retries - 1;
  let wait2 = 0;
  const promiseAttempt = async () => {
    var _a;
    try {
      let result;
      if (wait2 <= 0) {
        result = await asyncCallable();
      } else {
        result = await new Promise(
          (resolve, reject) => setTimeout(() => {
            asyncCallable().then(resolve).catch(reject);
          }, wait2)
        );
      }
      if (remainingAttempts) {
        validator == null ? void 0 : validator(result);
      }
      return result;
    } catch (error) {
      if (remainingAttempts-- > 0 && !(expectedErrorHandler == null ? void 0 : expectedErrorHandler(error))) {
        wait2 = (_a = delayFn == null ? void 0 : delayFn()) != null ? _a : 0;
        getLogger().debug(
          `Retrying request: ${retries - remainingAttempts} of ${retries}`
        );
        return promiseAttempt();
      } else {
        throw error;
      }
    }
  };
  return promiseAttempt();
};

// src/utils/index.ts
var safeParseJson = (value) => {
  if (typeof value !== "string") {
    return value;
  }
  try {
    return JSON.parse(value);
  } catch (error) {
    return value;
  }
};
var PROTOCOL_PATTERN = /^(ws|wss):\/\//;
var checkWebSocketHost = (host) => {
  const protocol = PROTOCOL_PATTERN.test(host) ? "" : "wss://";
  return `${protocol}${host}`;
};
var timeoutPromise = (promise, time, exception) => {
  let timer = null;
  return Promise.race([
    promise,
    new Promise(
      (_resolve, reject) => timer = setTimeout(reject, time, exception)
    )
  ]).finally(() => clearTimeout(timer));
};
var isGlobalEvent = (event) => {
  return GLOBAL_VIDEO_EVENTS.includes(event);
};
var isSyntheticEvent = (event) => {
  return event.includes(SYNTHETIC_EVENT_PREFIX);
};
var isSessionEvent = (event) => {
  return event.includes("session.");
};
var cleanupEventNamespace = (event) => {
  const eventParts = event.split(EVENT_NAMESPACE_DIVIDER);
  return eventParts[eventParts.length - 1];
};
var WITH_CUSTOM_EVENT_NAMES = [
  "video.member.updated",
  "video.member.talking"
];
var CLIENT_SIDE_EVENT_NAMES = [
  "video.room.joined",
  // generated client-side
  "video.track",
  "video.active",
  "video.answering",
  "video.destroy",
  "video.early",
  "video.hangup",
  "video.held",
  "video.new",
  "video.purge",
  "video.recovering",
  "video.requesting",
  "video.ringing",
  "video.trying",
  "video.media.connected",
  "video.media.reconnecting",
  "video.media.disconnected",
  "video.microphone.updated",
  "video.camera.updated",
  "video.speaker.updated",
  "video.microphone.disconnected",
  "video.camera.disconnected",
  "video.speaker.disconnected"
];
var validateEventsToSubscribe = (events) => {
  const valid = events.map((internalEvent) => {
    if (typeof internalEvent === "string") {
      const event = cleanupEventNamespace(internalEvent);
      if (CLIENT_SIDE_EVENT_NAMES.includes(event) || isSyntheticEvent(event) || isLocalEvent(event) || isSessionEvent(event)) {
        return null;
      }
      const found = WITH_CUSTOM_EVENT_NAMES.find((withCustomName) => {
        return event.startsWith(withCustomName);
      });
      return found || event;
    }
    return internalEvent;
  });
  return Array.from(new Set(valid)).filter(Boolean);
};
var isLocalEvent = (event) => {
  return event.includes(LOCAL_EVENT_PREFIX);
};
var toLocalEvent = (event) => {
  const eventParts = event.split(".");
  const prefix = eventParts[0];
  return event.split(".").reduce((reducer, item) => {
    reducer.push(item);
    if (item === prefix) {
      reducer.push(LOCAL_EVENT_PREFIX);
    }
    return reducer;
  }, []).join(".");
};
var toSyntheticEvent = (event) => {
  const eventParts = event.split(".");
  const prefix = eventParts[0];
  return event.split(".").reduce((reducer, item) => {
    reducer.push(item);
    if (item === prefix) {
      reducer.push(SYNTHETIC_EVENT_PREFIX);
    }
    return reducer;
  }, []).join(".");
};
var isJSONRPCRequest = (e) => {
  return Boolean(e.method);
};
var isJSONRPCResponse = (e) => {
  return !isJSONRPCRequest(e);
};
var isSATAuth = (e) => {
  return typeof e !== "undefined" && "jti" in e;
};
var isConnectRequest = (e) => isJSONRPCRequest(e) && e.method == "signalwire.connect";
var isVertoInvite = (e) => {
  var _a;
  return isJSONRPCRequest(e) && e.method == "webrtc.verto" && ((_a = e.params) == null ? void 0 : _a.message.method) === "verto.invite";
};

// src/RPCMessages/helpers.ts
var makeRPCRequest = (params) => {
  var _a;
  return __spreadValues({
    jsonrpc: "2.0",
    id: (_a = params.id) != null ? _a : v4()
  }, params);
};
var makeRPCResponse = (params) => {
  return __spreadValues({
    jsonrpc: "2.0"
  }, params);
};

// src/RPCMessages/RPCConnect.ts
var DEFAULT_CONNECT_VERSION = {
  major: 3,
  minor: 0,
  revision: 0
};
var UNIFIED_CONNECT_VERSION = {
  major: 4,
  minor: 0,
  revision: 0
};
var RPCConnect = (params) => {
  return makeRPCRequest({
    method: "signalwire.connect",
    params: __spreadValues({
      version: DEFAULT_CONNECT_VERSION,
      event_acks: true
    }, params)
  });
};

// src/RPCMessages/RPCReauthenticate.ts
var RPCReauthenticate = (authentication) => {
  return makeRPCRequest({
    method: "signalwire.reauthenticate",
    params: {
      authentication
    }
  });
};

// src/RPCMessages/RPCPing.ts
var RPCPing = () => {
  return makeRPCRequest({
    method: "signalwire.ping",
    params: {
      timestamp: Date.now() / 1e3
    }
  });
};
var RPCPingResponse = (id, timestamp) => {
  return makeRPCResponse({
    id,
    result: {
      timestamp: timestamp || Date.now() / 1e3
    }
  });
};

// src/RPCMessages/RPCExecute.ts
var RPCExecute = ({ method, params }) => {
  return makeRPCRequest({
    method,
    params
  });
};

// src/RPCMessages/RPCDisconnect.ts
var RPCDisconnectResponse = (id) => {
  return makeRPCResponse({
    id,
    result: {}
  });
};

// src/RPCMessages/VertoMessages.ts
var tmpMap = {
  id: "callID",
  destinationNumber: "destination_number",
  remoteCallerName: "remote_caller_id_name",
  remoteCallerNumber: "remote_caller_id_number",
  callerName: "caller_id_name",
  callerNumber: "caller_id_number",
  fromFabricAddressId: "from_fabric_address_id"
};
var filterVertoParams = (params) => {
  if (params.hasOwnProperty("dialogParams")) {
    const _a = params.dialogParams, {
      remoteSdp,
      localStream,
      remoteStream
    } = _a, dialogParams = __objRest(_a, [
      "remoteSdp",
      "localStream",
      "remoteStream"
    ]);
    for (const key in tmpMap) {
      if (key && dialogParams.hasOwnProperty(key)) {
        dialogParams[tmpMap[key]] = dialogParams[key];
        delete dialogParams[key];
      }
    }
    params.dialogParams = dialogParams;
  }
  return params;
};
var buildVertoRPCMessage = (method) => {
  return (params = {}) => {
    return makeRPCRequest({
      method,
      params: filterVertoParams(params)
    });
  };
};
var VertoInvite = buildVertoRPCMessage("verto.invite");
var VertoBye = buildVertoRPCMessage("verto.bye");
var VertoAttach = buildVertoRPCMessage("verto.attach");
var VertoModify = buildVertoRPCMessage("verto.modify");
var VertoInfo = buildVertoRPCMessage("verto.info");
var VertoAnswer = buildVertoRPCMessage("verto.answer");
var VertoSubscribe = buildVertoRPCMessage("verto.subscribe");
var VertoPong = buildVertoRPCMessage("verto.pong");
var VertoResult = (id, method) => {
  return makeRPCResponse({
    id,
    result: {
      method
    }
  });
};

// src/RPCMessages/RPCEventAck.ts
var RPCEventAckResponse = (id) => makeRPCResponse({ id, result: {} });

// src/redux/actions.ts
var actions_exports = {};
__export(actions_exports, {
  authErrorAction: () => authErrorAction,
  authExpiringAction: () => authExpiringAction,
  authSuccessAction: () => authSuccessAction,
  createAction: () => createAction,
  destroyAction: () => destroyAction,
  getCustomSagaActionType: () => getCustomSagaActionType,
  initAction: () => initAction,
  makeCustomSagaAction: () => makeCustomSagaAction,
  reauthAction: () => reauthAction,
  sessionDisconnectedAction: () => sessionDisconnectedAction,
  sessionForceCloseAction: () => sessionForceCloseAction,
  sessionReconnectingAction: () => sessionReconnectingAction,
  socketMessageAction: () => socketMessageAction
});

// src/redux/toolkit/index.ts
var toolkit_exports = {};
__export(toolkit_exports, {
  configureStore: () => configureStore,
  createAction: () => createAction
});
__reExport(toolkit_exports, redux_star);
import * as redux_star from "redux";

// src/redux/toolkit/createAction.ts
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues(__spreadValues({
        type,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type, payload: args[0] };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => action.type === type;
  return actionCreator;
}

// src/redux/toolkit/configureStore.ts
import { createStore, compose as compose2, applyMiddleware, combineReducers } from "redux";

// src/redux/toolkit/devtoolsExtension.ts
import { compose } from "redux";
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop) {
    return noop;
  };
};

// src/redux/toolkit/isPlainObject.ts
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) return false;
  let proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  let baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}

// src/redux/toolkit/getDefaultMiddleware.ts
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware() {
    return [];
  };
}

// src/redux/toolkit/configureStore.ts
var IS_PRODUCTION = process.env.NODE_ENV === "production";
function configureStore(options) {
  const curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware = curriedGetDefaultMiddleware(),
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer2;
  if (typeof reducer === "function") {
    rootReducer2 = reducer;
  } else if (isPlainObject(reducer)) {
    rootReducer2 = combineReducers(reducer);
  } else {
    throw new Error(
      '"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'
    );
  }
  let finalMiddleware = middleware;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
      throw new Error(
        "when using a middleware builder function, an array of middleware must be returned"
      );
    }
  }
  if (!IS_PRODUCTION && finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error(
      "each middleware provided to configureStore must be a function"
    );
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  let finalCompose = compose2;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues({
      // Enable capture of stack traces for dispatched Redux actions
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  let storeEnhancers = [middlewareEnhancer];
  if (Array.isArray(enhancers)) {
    storeEnhancers = [middlewareEnhancer, ...enhancers];
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(storeEnhancers);
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer2, preloadedState, composedEnhancer);
}

// src/redux/actions.ts
var initAction = createAction("swSdk/init");
var destroyAction = createAction("swSdk/destroy");
var reauthAction = createAction("swSdk/reauth");
var authErrorAction = createAction(
  "auth/error"
);
var authSuccessAction = createAction("auth/success");
var authExpiringAction = createAction("auth/expiring");
var socketMessageAction = createAction(
  "socket/message"
);
var sessionDisconnectedAction = createAction(
  "session.disconnected"
);
var sessionReconnectingAction = createAction(
  "session.reconnecting"
);
var sessionForceCloseAction = createAction(
  "session.forceClose"
);
var formatCustomSagaAction = (id, action) => {
  return `${action.type}/${id}`;
};
var makeCustomSagaAction = (id, action) => {
  return __spreadProps(__spreadValues({}, action), {
    type: formatCustomSagaAction(id, action)
  });
};
var getCustomSagaActionType = (id, action) => {
  return formatCustomSagaAction(id, action);
};

// src/redux/toolkit/mapBuilders.ts
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (actionMatchers.length > 0) {
          throw new Error(
            "`builder.addCase` should only be called before calling `builder.addMatcher`"
          );
        }
        if (defaultCaseReducer) {
          throw new Error(
            "`builder.addCase` should only be called before calling `builder.addDefaultCase`"
          );
        }
      }
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (type in actionsMap) {
        throw new Error(
          "addCase cannot be called with two reducers for the same action type"
        );
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher(matcher, reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error(
            "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`"
          );
        }
      }
      actionMatchers.push({ matcher, reducer });
      return builder;
    },
    addDefaultCase(reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error("`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}

// src/redux/toolkit/createReducer.ts
function isStateFunction(x) {
  return typeof x === "function";
}
function createReducer(initialState, mapOrBuilderCallback, actionMatchers = [], defaultCaseReducer) {
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer];
  let getInitialState;
  if (isStateFunction(initialState)) {
    getInitialState = () => initialState();
  } else {
    getInitialState = () => initialState;
  }
  function reducer(state = getInitialState(), action) {
    let caseReducers = [
      actionsMap[action.type],
      ...finalActionMatchers.filter(({ matcher }) => matcher(action)).map(({ reducer: reducer2 }) => reducer2)
    ];
    if (caseReducers.filter((cr) => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        return caseReducer(previousState, action);
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}

// src/redux/toolkit/createSlice.ts
function getType(slice, actionKey) {
  return `${slice}/${actionKey}`;
}
function createSlice(options) {
  const { name } = options;
  if (!name) {
    throw new Error("`name` is a required option for createSlice");
  }
  const initialState = options.initialState;
  const reducers = options.reducers || {};
  const reducerNames = Object.keys(reducers);
  const sliceCaseReducersByName = {};
  const sliceCaseReducersByType = {};
  const actionCreators = {};
  reducerNames.forEach((reducerName) => {
    const maybeReducerWithPrepare = reducers[reducerName];
    const type = getType(name, reducerName);
    let caseReducer;
    let prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
  });
  function buildReducer() {
    const [
      extraReducers = {},
      actionMatchers = [],
      defaultCaseReducer = void 0
    ] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
    const finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
    return createReducer(
      initialState,
      finalCaseReducers,
      actionMatchers,
      defaultCaseReducer
    );
  }
  let _reducer;
  return {
    name,
    reducer(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}

// src/redux/utils/createDestroyableSlice.ts
var createDestroyableSlice = ({
  name = "",
  initialState,
  reducers,
  extraReducers
}) => {
  return createSlice({
    name,
    initialState,
    reducers,
    extraReducers: (builder) => {
      builder.addCase(destroyAction.type, () => {
        return initialState;
      });
      if (typeof extraReducers === "function") {
        extraReducers(builder);
      }
    }
  });
};

// src/redux/features/session/sessionSlice.ts
var initialSessionState = {
  protocol: "",
  iceServers: [],
  authStatus: "unknown",
  authorization: void 0,
  authorizationState: void 0,
  authError: void 0,
  authCount: 0
};
function authorizingAction(action) {
  return [initAction.type, reauthAction.type].includes(action.type);
}
var sessionSlice = createDestroyableSlice({
  name: "session",
  initialState: initialSessionState,
  reducers: {
    connected: (state, { payload }) => {
      var _a, _b;
      return __spreadProps(__spreadValues({}, state), {
        authStatus: "authorized",
        authorization: payload == null ? void 0 : payload.authorization,
        authCount: state.authCount + 1,
        protocol: (_a = payload == null ? void 0 : payload.protocol) != null ? _a : "",
        iceServers: (_b = payload == null ? void 0 : payload.ice_servers) != null ? _b : []
      });
    },
    authStatus: (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        authStatus: payload
      });
    },
    updateAuthorization: (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        authorization: payload
      });
    },
    updateAuthorizationState: (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        authorizationState: payload
      });
    }
  },
  extraReducers: (builder) => {
    builder.addCase(
      authErrorAction.type,
      (state, { payload }) => {
        return __spreadProps(__spreadValues({}, state), {
          authStatus: "unauthorized",
          authError: payload.error
        });
      }
    );
    builder.addMatcher(authorizingAction, (state) => {
      return __spreadProps(__spreadValues({}, state), {
        authStatus: "authorizing"
      });
    });
  }
});
var {
  actions: sessionActions,
  reducer: sessionReducer
} = sessionSlice;

// src/BaseSession.ts
var SW_SYMBOL = Symbol("BaseSession");
var randomInt = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1) + min);
};
var reconnectDelay = () => {
  return randomInt(1, 4) * 1e3;
};
var BaseSession = class {
  constructor(options) {
    this.options = options;
    /** @internal */
    __publicField(this, "__sw_symbol", SW_SYMBOL);
    __publicField(this, "uuid", v4());
    __publicField(this, "WebSocketConstructor");
    __publicField(this, "CloseEventConstructor");
    __publicField(this, "agent");
    __publicField(this, "connectVersion", DEFAULT_CONNECT_VERSION);
    __publicField(this, "_rpcConnectResult");
    __publicField(this, "_requests", /* @__PURE__ */ new Map());
    __publicField(this, "_socket", null);
    __publicField(this, "_host", DEFAULT_HOST);
    __publicField(this, "_executeTimeoutMs", 10 * 1e3);
    __publicField(this, "_executeTimeoutError", SYMBOL_EXECUTE_TIMEOUT);
    __publicField(this, "_executeQueue", /* @__PURE__ */ new Set());
    __publicField(this, "_swConnectError", SYMBOL_CONNECT_ERROR);
    __publicField(this, "_executeConnectionClosed", SYMBOL_EXECUTE_CONNECTION_CLOSED);
    __publicField(this, "_checkPingDelay", 15 * 1e3);
    __publicField(this, "_checkPingTimer", null);
    __publicField(this, "_reconnectTimer");
    __publicField(this, "_status", "unknown");
    __publicField(this, "_resolveWaitConnected", null);
    __publicField(this, "_sessionChannel");
    __publicField(this, "wsOpenHandler");
    __publicField(this, "wsCloseHandler");
    __publicField(this, "wsErrorHandler");
    var _a, _b;
    const { host, logLevel = "info", sessionChannel } = options;
    if (host) {
      this._host = checkWebSocketHost(host);
    }
    if (sessionChannel) {
      this._sessionChannel = sessionChannel;
    }
    if (logLevel) {
      (_b = (_a = this.logger).setLevel) == null ? void 0 : _b.call(_a, logLevel);
    }
    this._onSocketOpen = this._onSocketOpen.bind(this);
    this._onSocketError = this._onSocketError.bind(this);
    this._onSocketClose = this._onSocketClose.bind(this);
    this._onSocketMessage = this._onSocketMessage.bind(this);
    this.execute = this.execute.bind(this);
    this.connect = this.connect.bind(this);
    this.wsOpenHandler = (event) => {
      var _a2;
      (_a2 = this._socket) == null ? void 0 : _a2.removeEventListener("open", this.wsOpenHandler);
      this._onSocketOpen(event);
    };
    this.wsCloseHandler = (event) => {
      var _a2;
      (_a2 = this._socket) == null ? void 0 : _a2.removeEventListener("close", this.wsCloseHandler);
      this._onSocketClose(event);
    };
    this.wsErrorHandler = (event) => {
      var _a2;
      (_a2 = this._socket) == null ? void 0 : _a2.removeEventListener("error", this.wsErrorHandler);
      this._onSocketError(event);
    };
  }
  get host() {
    return this._host;
  }
  get rpcConnectResult() {
    return this._rpcConnectResult;
  }
  get relayProtocol() {
    var _a, _b;
    return (_b = (_a = this._rpcConnectResult) == null ? void 0 : _a.protocol) != null ? _b : "";
  }
  get signature() {
    if (this._rpcConnectResult) {
      const { authorization } = this._rpcConnectResult;
      return authorization.signature;
    }
    return void 0;
  }
  get logger() {
    return getLogger();
  }
  get connecting() {
    var _a;
    return ((_a = this._socket) == null ? void 0 : _a.readyState) === 0 /* CONNECTING */;
  }
  get connected() {
    var _a;
    return ((_a = this._socket) == null ? void 0 : _a.readyState) === 1 /* OPEN */;
  }
  get closing() {
    var _a;
    return ((_a = this._socket) == null ? void 0 : _a.readyState) === 2 /* CLOSING */;
  }
  get closed() {
    return this._socket ? this._socket.readyState === 3 /* CLOSED */ : true;
  }
  get status() {
    return this._status;
  }
  get idle() {
    return this._status === "idle";
  }
  get ready() {
    return !Boolean(this.idle || !this.connected);
  }
  async _waitConnected() {
    return new Promise((resolve) => {
      if (this.connected) {
        resolve();
      } else {
        this._resolveWaitConnected = resolve;
      }
    });
  }
  set token(token) {
    this.options.token = token;
  }
  /**
   * Connect the websocket
   *
   * @return void
   */
  connect() {
    if (!(this == null ? void 0 : this.WebSocketConstructor)) {
      throw new Error("Missing WebSocketConstructor");
    }
    if (!(this == null ? void 0 : this.CloseEventConstructor)) {
      throw new Error("Missing CloseEventConstructor");
    }
    this._clearTimers();
    if (this.connecting || this.connected) {
      this.logger.warn("Session already connected.");
      return;
    }
    this._removeSocketListeners();
    this.destroySocket();
    this._clearCheckPingTimer();
    this._socket = this._createSocket();
    this._addSocketListeners();
  }
  /**
   * Allow children classes to override it.
   * @return WebSocket instance
   */
  _createSocket() {
    return new this.WebSocketConstructor(this._host);
  }
  /** Allow children classes to override it. */
  destroySocket() {
    if (this._socket) {
      this._socket.close();
      this.wsCloseHandler(
        new this.CloseEventConstructor("close", {
          reason: "Client-side closed"
        })
      );
      this._socket = null;
    }
  }
  _addSocketListeners() {
    if (!this._socket) {
      return this.logger.debug("Invalid socket instance to add listeners");
    }
    this._removeSocketListeners();
    this._socket.addEventListener("open", this.wsOpenHandler);
    this._socket.addEventListener("close", this.wsCloseHandler);
    this._socket.addEventListener("error", this.wsErrorHandler);
    this._socket.addEventListener("message", this._onSocketMessage);
  }
  _removeSocketListeners() {
    if (!this._socket) {
      return this.logger.debug("Invalid socket instance to remove listeners");
    }
    this._socket.removeEventListener("open", this.wsOpenHandler);
    this._socket.removeEventListener("close", this.wsCloseHandler);
    this._socket.removeEventListener("error", this.wsErrorHandler);
    this._socket.removeEventListener("message", this._onSocketMessage);
  }
  /**
   * Clear the Session and close the WS connection.
   * @return void
   */
  disconnect() {
    if (!this._socket || this.closing) {
      this.logger.debug("Session not connected or already in closing state.");
      return;
    }
    this._status = "disconnecting";
    this._checkCurrentStatus();
  }
  /**
   * Send a JSON object to the server.
   * @return Promise that will resolve/reject depending on the server response
   */
  execute(msg) {
    if (this._status === "disconnecting") {
      this.logger.warn(
        "Reject request because the session is disconnecting",
        msg
      );
      return Promise.reject({
        code: "400",
        message: "The SDK session is disconnecting"
      });
    }
    if (this._status === "disconnected") {
      return Promise.reject({
        code: "400",
        message: "The SDK is disconnected"
      });
    }
    let promise = Promise.resolve();
    if ("params" in msg) {
      promise = new Promise((resolve, reject) => {
        this._requests.set(msg.id, { rpcRequest: msg, resolve, reject });
      });
    }
    if (!this.ready) {
      this._addToExecuteQueue(msg);
      this.connect();
      return promise;
    }
    this._send(msg);
    return timeoutPromise(
      promise,
      this._executeTimeoutMs,
      this._executeTimeoutError
    ).catch((error) => {
      if (error === this._executeConnectionClosed) {
        throw this._executeConnectionClosed;
      } else if (error === this._executeTimeoutError) {
        if (isConnectRequest(msg)) {
          throw this._swConnectError;
        }
        this._checkCurrentStatus();
        this.logger.error("Request Timeout", msg);
        if (this.status === "disconnected") {
          return this.logger.debug(
            "Request failed because the session is disconnected",
            this.status,
            this._socket
          );
        }
        this._closeConnection("reconnecting");
      } else {
        throw error;
      }
    });
  }
  get _connectParams() {
    return {
      agent: this.agent,
      version: this.connectVersion,
      authentication: {
        project: this.options.project,
        token: this.options.token
      }
    };
  }
  /**
   * Authenticate with the SignalWire Network
   * @return Promise<void>
   */
  async authenticate() {
    var _a, _b;
    const params = this._connectParams;
    if (this._relayProtocolIsValid()) {
      params.protocol = this.relayProtocol;
    }
    if ((_a = this.options.topics) == null ? void 0 : _a.length) {
      params.contexts = this.options.topics;
    } else if ((_b = this.options.contexts) == null ? void 0 : _b.length) {
      params.contexts = this.options.contexts;
    }
    this._rpcConnectResult = await this.execute(RPCConnect(params));
  }
  authError(error) {
    this._removeSocketListeners();
    this.dispatch(authErrorAction({ error }));
  }
  forceClose() {
    this._removeSocketListeners();
    return this._closeConnection("reconnecting");
  }
  async _onSocketOpen(event) {
    var _a;
    this.logger.debug("_onSocketOpen", event.type);
    try {
      this._status = "unknown";
      this._clearTimers();
      await this.authenticate();
      this._status = "connected";
      (_a = this._resolveWaitConnected) == null ? void 0 : _a.call(this);
      this._flushExecuteQueue();
      this.dispatch(authSuccessAction());
    } catch (error) {
      if (error === this._swConnectError || error === this._executeConnectionClosed) {
        this.logger.debug(
          "Invalid connect or connection closed. Waiting for retry."
        );
        return;
      }
      this.logger.error("Auth Error", error);
      this.authError(error);
    }
  }
  _onSocketError(event) {
    this.logger.debug("_onSocketError", event);
  }
  _onSocketClose(event) {
    this.logger.debug("_onSocketClose", event.type, event.code, event.reason);
    if (this._status !== "disconnected") {
      this._status = "reconnecting";
      this.dispatch(sessionReconnectingAction());
      this._clearTimers();
      this._clearPendingRequests();
      this._reconnectTimer = setTimeout(() => {
        this.connect();
      }, reconnectDelay());
    }
    this._socket = null;
  }
  _clearTimers() {
    clearTimeout(this._reconnectTimer);
  }
  _clearPendingRequests() {
    this.logger.debug("_clearPendingRequests", this._requests.size);
    this._requests.forEach(({ reject }) => {
      reject(this._executeConnectionClosed);
    });
    this._requests.clear();
  }
  _onSocketMessage(event) {
    const payload = this.decode(event.data);
    this.logger.wsTraffic({ type: "recv", payload });
    if (isJSONRPCResponse(payload)) {
      const request = this._requests.get(payload.id);
      if (request) {
        const { rpcRequest, resolve, reject } = request;
        this._requests.delete(payload.id);
        const { result, error } = parseRPCResponse({
          response: payload,
          request: rpcRequest
        });
        this._checkCurrentStatus();
        return error ? reject(error) : resolve(result);
      }
      return this.logger.warn("Unknown request for", payload);
    }
    switch (payload.method) {
      case "signalwire.ping":
        return this._pingHandler(payload);
      case "signalwire.disconnect": {
        this.execute(RPCDisconnectResponse(payload.id)).catch((error) => {
          this.logger.error("SwDisconnect Error", error);
        }).finally(() => {
          this._status = "idle";
        });
        break;
      }
      default:
        this._eventAcknowledgingHandler(payload).catch(
          (error) => this.logger.error("Event Acknowledging Error", error)
        );
        this.dispatch(socketMessageAction(payload));
    }
  }
  dispatch(_payload) {
    if (!this._sessionChannel) {
      throw new Error("Session channel does not exist");
    }
    this._sessionChannel.put(_payload);
  }
  /**
   * Check the current relayProtocol against the signature
   * to make sure is still valid.
   * @return boolean
   */
  _relayProtocolIsValid() {
    var _a;
    return this.signature && ((_a = this == null ? void 0 : this.relayProtocol) == null ? void 0 : _a.split("_")[1]) === this.signature;
  }
  encode(input) {
    return JSON.stringify(input);
  }
  decode(input) {
    return safeParseJson(input);
  }
  async onSwAuthorizationState(state) {
    this.persistSwAuthorizationState(state);
  }
  async retrieveSwAuthorizationState() {
    return "";
  }
  async persistSwAuthorizationState(_) {
  }
  _send(msg) {
    this.logger.wsTraffic({ type: "send", payload: msg });
    this._socket.send(this.encode(msg));
  }
  _addToExecuteQueue(msg) {
    this.logger.warn("Request queued waiting for session to reconnect", msg);
    this._executeQueue.add(msg);
  }
  _flushExecuteQueue() {
    if (!this._executeQueue.size) {
      return;
    }
    if (!this.ready) {
      this.logger.warn(`Session not ready to flush the queue.`);
      this._closeConnection("reconnecting");
      return;
    }
    this.logger.debug(`${this._executeQueue.size} messages to flush`);
    this._executeQueue.forEach((msg) => {
      this._send(msg);
      this._executeQueue.delete(msg);
    });
    this._executeQueue.clear();
  }
  _clearCheckPingTimer() {
    clearTimeout(this._checkPingTimer);
  }
  async _pingHandler(payload) {
    var _a;
    this._clearCheckPingTimer();
    this._checkPingTimer = setTimeout(() => {
      this.logger.debug("Timeout waiting for ping");
      this._closeConnection("reconnecting");
    }, this._checkPingDelay);
    await this.execute(RPCPingResponse(payload.id, (_a = payload == null ? void 0 : payload.params) == null ? void 0 : _a.timestamp));
  }
  async _eventAcknowledgingHandler(payload) {
    const { method, id } = payload;
    if (method === "signalwire.event") {
      return this.execute(RPCEventAckResponse(id));
    }
    return Promise.resolve();
  }
  /**
   * Do something based on the current `this._status`
   */
  _checkCurrentStatus() {
    switch (this._status) {
      // Only close the WS connection if there are no pending requests
      case "disconnecting":
        if (this._requests.size > 0) {
          return;
        }
        this._requests.clear();
        this._closeConnection("disconnected");
        break;
      case "disconnected":
        this.dispatch(sessionDisconnectedAction());
        break;
      case "reconnecting":
        this.wsCloseHandler(
          new this.CloseEventConstructor("close", {
            reason: "Client-side closed"
          })
        );
        break;
    }
  }
  _closeConnection(status) {
    this._clearCheckPingTimer();
    this.logger.debug("Close Connection:", status);
    this._status = status;
    this.dispatch(
      sessionActions.authStatus(
        status === "disconnected" ? "unauthorized" : "unknown"
      )
    );
    this._removeSocketListeners();
    this.destroySocket();
    this._checkCurrentStatus();
  }
};

// src/BaseJWTSession.ts
var BaseJWTSession = class extends BaseSession {
  constructor(options) {
    super(options);
    this.options = options;
    /**
     * Can set a value different than zero to
     * force the JWT as expired within X seconds.
     * TODO: Remove this workaround.
     */
    __publicField(this, "_expiredDiffSeconds", 0);
    __publicField(this, "_refreshTokenNotificationDiff", 120);
    /**
     * Check the JWT expiration every 20seconds
     */
    __publicField(this, "_checkTokenExpirationDelay", 20 * 1e3);
    __publicField(this, "_checkTokenExpirationTimer", null);
    this._checkTokenExpiration = this._checkTokenExpiration.bind(this);
    this.reauthenticate = this.reauthenticate.bind(this);
  }
  get expiresAt() {
    var _a;
    if (!(this == null ? void 0 : this._rpcConnectResult)) {
      return 0;
    }
    const { authorization } = this._rpcConnectResult;
    const expiresAt = (_a = isSATAuth(authorization) ? authorization.fabric_subscriber.expires_at : authorization == null ? void 0 : authorization.expires_at) != null ? _a : 0;
    if (typeof expiresAt === "string") {
      const parsed = Date.parse(expiresAt);
      if (!isNaN(parsed)) {
        return Math.floor(parsed / 1e3);
      }
    }
    return expiresAt;
  }
  get expiresIn() {
    const now = Math.floor(Date.now() / 1e3);
    return this.expiresAt - now;
  }
  get expired() {
    return this.expiresAt > 0 && this.expiresIn <= this._expiredDiffSeconds;
  }
  /**
   * Authenticate with the SignalWire Network
   * using JWT
   * @return Promise<void>
   */
  async authenticate() {
    const params = __spreadProps(__spreadValues({}, this._connectParams), {
      authentication: {
        jwt_token: this.options.token
      }
    });
    if (this._relayProtocolIsValid()) {
      params.protocol = this.relayProtocol;
    } else {
      const prevProtocol = await this.retrieveRelayProtocol();
      if (prevProtocol) {
        params.protocol = prevProtocol;
      }
    }
    if (params.protocol) {
      const authorizationState = await this.retrieveSwAuthorizationState();
      if (authorizationState) {
        params.authorization_state = authorizationState;
      }
    }
    try {
      this._rpcConnectResult = await this.execute(RPCConnect(params));
      await this.persistRelayProtocol();
      await this._checkTokenExpiration();
    } catch (error) {
      this.logger.debug("BaseJWTSession authenticate error", error);
      if (error.message === "Requester validation failed") {
        this.removeRelayProtocol();
        this.removeSwAuthorizationState();
        this.removePrevCallId();
        await this.authenticate();
        return;
      }
      throw error;
    }
  }
  async retrieveRelayProtocol() {
    return "";
  }
  async persistRelayProtocol() {
  }
  removeRelayProtocol() {
  }
  removeSwAuthorizationState() {
  }
  removePrevCallId() {
  }
  /**
   * Reauthenticate with the SignalWire Network
   * using a newer JWT. If the session has expired
   * will reconnect it.
   * @return Promise<void>
   */
  async reauthenticate() {
    this.logger.debug("Session Reauthenticate", {
      ready: this.ready,
      expired: this.expired
    });
    if (!this.ready || this.expired) {
      return this.connect();
    }
    const params = {
      project: this._rpcConnectResult.authorization.project_id,
      jwt_token: this.options.token
    };
    try {
      this._rpcConnectResult = await this.execute(RPCReauthenticate(params));
    } catch (error) {
      clearTimeout(this._checkTokenExpirationTimer);
      throw error;
    }
  }
  _onSocketClose(event) {
    clearTimeout(this._checkTokenExpirationTimer);
    super._onSocketClose(event);
  }
  /**
   * Set a timer to dispatch a notification when the JWT is going to expire.
   * @return void
   */
  async _checkTokenExpiration() {
    if (!this.expiresAt) {
      return;
    }
    const refreshTokenFn = this.options.onRefreshToken;
    if (this.expiresIn <= this._refreshTokenNotificationDiff) {
      this.dispatch(authExpiringAction());
      if (typeof refreshTokenFn === "function") {
        try {
          const token = await refreshTokenFn();
          this.dispatch(reauthAction({ token }));
        } catch (error) {
          this.logger.error(error);
        }
      } else {
        this.logger.warn("The token is going to expire!");
      }
    }
    clearTimeout(this._checkTokenExpirationTimer);
    if (!this.expired) {
      this._checkTokenExpirationTimer = setTimeout(
        this._checkTokenExpiration,
        this._checkTokenExpirationDelay
      );
    }
  }
};

// src/redux/index.ts
var redux_exports = {};
__export(redux_exports, {
  authErrorAction: () => authErrorAction,
  authExpiringAction: () => authExpiringAction,
  authSuccessAction: () => authSuccessAction,
  configureStore: () => configureStore2,
  connect: () => connect,
  createAction: () => createAction,
  createCatchableSaga: () => createCatchableSaga,
  createRestartableSaga: () => createRestartableSaga,
  destroyAction: () => destroyAction,
  eventChannel: () => eventChannel,
  getCustomSagaActionType: () => getCustomSagaActionType,
  initAction: () => initAction,
  makeCustomSagaAction: () => makeCustomSagaAction,
  reauthAction: () => reauthAction,
  sessionDisconnectedAction: () => sessionDisconnectedAction,
  sessionForceCloseAction: () => sessionForceCloseAction,
  sessionReconnectingAction: () => sessionReconnectingAction,
  socketMessageAction: () => socketMessageAction
});
import createSagaMiddleware, {
  channel,
  multicastChannel
} from "@redux-saga/core";

// src/redux/features/component/componentSlice.ts
var initialComponentState = {
  byId: {}
};
var componentSlice = createDestroyableSlice({
  name: "components",
  initialState: initialComponentState,
  reducers: {
    upsert: (state, { payload }) => {
      if (payload.id in state.byId) {
        return __spreadProps(__spreadValues({}, state), {
          byId: __spreadProps(__spreadValues({}, state.byId), {
            [payload.id]: __spreadValues(__spreadValues({}, state.byId[payload.id]), payload)
          })
        });
      } else {
        return __spreadProps(__spreadValues({}, state), {
          byId: __spreadProps(__spreadValues({}, state.byId), {
            [payload.id]: payload
          })
        });
      }
    },
    cleanup: (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        byId: Object.entries(state.byId).reduce(
          (reducer, [componentId, value]) => {
            if (!payload.ids.includes(componentId)) {
              reducer[componentId] = value;
            }
            return reducer;
          },
          {}
        )
      });
    }
  }
});
var {
  actions: componentActions,
  reducer: componentReducer
} = componentSlice;

// src/redux/rootReducer.ts
var rootReducer = (0, toolkit_exports.combineReducers)({
  components: componentReducer,
  session: sessionReducer
});

// src/redux/rootSaga.ts
import { fork as fork2, call as call2, take as take2, put as put2, all, cancelled } from "@redux-saga/core/effects";

// src/redux/features/session/sessionSaga.ts
import { put, take, fork } from "@redux-saga/core/effects";

// src/redux/utils/sagaHelpers.ts
var sagaHelpers_exports = {};
__export(sagaHelpers_exports, {
  createCatchableSaga: () => createCatchableSaga,
  createRestartableSaga: () => createRestartableSaga,
  eventChannel: () => eventChannel
});
import { call, spawn } from "@redux-saga/core/effects";
import { eventChannel } from "@redux-saga/core";
var createRestartableSaga = (saga) => {
  return function* () {
    spawn(function* () {
      while (true) {
        try {
          getLogger().debug("Run a restartable saga");
          yield call(saga);
          getLogger().debug(
            "One of the restartable saga has ended. Restarting.."
          );
        } catch (error) {
          getLogger().error("Restartable Saga Error", error);
        }
      }
    });
  };
};
var defaultCatchHandler = (error) => getLogger().error("Catchable Saga Error", error);
var createCatchableSaga = (saga, errorHandler = defaultCatchHandler) => {
  return function* (...params) {
    try {
      yield call(saga, ...params);
    } catch (error) {
      errorHandler(error);
    }
  };
};

// src/redux/features/session/sessionSaga.ts
var isWebrtcEvent = (e) => {
  return isWebrtcEventType(e == null ? void 0 : e.event_type);
};
var isVideoEvent = (e) => {
  var _a;
  return !!((_a = e == null ? void 0 : e.event_type) == null ? void 0 : _a.startsWith("video."));
};
var isSwAuthorizationStateEvent = (e) => {
  return (e == null ? void 0 : e.event_type) === "signalwire.authorization.state";
};
function* sessionChannelWatcher({
  sessionChannel,
  swEventChannel,
  session
}) {
  getLogger().debug("sessionChannelWatcher [started]");
  function* swEventWorker(broadcastParams) {
    yield put(swEventChannel, toInternalAction(broadcastParams));
    if (isWebrtcEvent(broadcastParams) || isVideoEvent(broadcastParams)) {
      return;
    }
    if (isSwAuthorizationStateEvent(broadcastParams)) {
      session.onSwAuthorizationState(broadcastParams.params.authorization_state);
      yield put(
        sessionActions.updateAuthorizationState(
          broadcastParams.params.authorization_state
        )
      );
      return;
    }
    yield put({ type: broadcastParams.event_type, payload: broadcastParams });
  }
  function* sessionChannelWorker(action) {
    if (action.type !== socketMessageAction.type) {
      yield put(action);
      return;
    }
    const { method, params } = action.payload;
    switch (method) {
      case "signalwire.event":
        yield fork(swEventWorker, params);
        break;
      default:
        return getLogger().debug(`Unknown message: ${method}`, action);
    }
  }
  const sessionChannelWorkerCatchable = createCatchableSaga(sessionChannelWorker, (error) => {
    getLogger().error("Channel Error", error);
  });
  while (true) {
    try {
      while (true) {
        const action = yield take(sessionChannel);
        yield fork(sessionChannelWorkerCatchable, action);
      }
    } catch (error) {
      getLogger().error("sessionChannelWorker error:", error);
    } finally {
      getLogger().debug("sessionChannelWorker [finally]");
    }
  }
}

// src/CustomErrors.ts
var AuthError = class _AuthError extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.message = message;
    __publicField(this, "name", "AuthError");
    Object.setPrototypeOf(this, _AuthError.prototype);
  }
};
var HttpError = class _HttpError extends Error {
  constructor(code, message, response) {
    super(message);
    this.code = code;
    this.message = message;
    this.response = response;
    __publicField(this, "name", "HttpError");
    Object.setPrototypeOf(this, _HttpError.prototype);
  }
};
var CapabilityError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CapabilityError";
  }
};

// src/redux/rootSaga.ts
function* sessionSaga({
  initSession,
  sessionEmitter,
  userOptions,
  channels
}) {
  var _a;
  getLogger().debug("sessionSaga [started]");
  const session = initSession();
  const swEventChannel = channels.swEventChannel;
  const sessionChannel = channels.sessionChannel;
  let customTasks = [];
  if ((_a = userOptions.workers) == null ? void 0 : _a.length) {
    try {
      const effects = userOptions.workers.map((saga) => {
        return call2(createRestartableSaga(saga));
      });
      customTasks = yield all(effects);
    } catch (error) {
      getLogger().error("Error running custom workers", error);
    }
  }
  const sessionChannelTask = yield fork2(sessionChannelWatcher, {
    session,
    sessionChannel,
    swEventChannel
  });
  const sessionStatusTask = yield fork2(sessionStatusWatcher, {
    session,
    sessionEmitter,
    sessionChannel,
    userOptions
  });
  session.connect();
  yield take2(destroyAction.type);
  session.disconnect();
  yield take2(sessionDisconnectedAction.type);
  sessionEmitter.emit("session.disconnected");
  sessionStatusTask.cancel();
  sessionChannelTask.cancel();
  customTasks.forEach((task) => task.cancel());
  swEventChannel.close();
  sessionChannel.close();
  getLogger().debug("sessionSaga [ended]");
}
function* reauthenticateWorker({
  session,
  token,
  sessionEmitter
}) {
  try {
    if (session.reauthenticate) {
      session.token = token;
      yield call2(session.reauthenticate);
      yield put2(sessionActions.connected(session.rpcConnectResult));
      sessionEmitter.emit("session.connected");
    }
  } catch (error) {
    getLogger().error("Reauthenticate Error", error);
    session.authError(error);
  }
}
function* sessionStatusWatcher(options) {
  getLogger().debug("sessionStatusWatcher [started]");
  const { session, sessionEmitter } = options;
  try {
    while (true) {
      const action = yield take2([
        authSuccessAction.type,
        authErrorAction.type,
        authExpiringAction.type,
        reauthAction.type,
        sessionReconnectingAction.type,
        sessionForceCloseAction.type
      ]);
      getLogger().debug("sessionStatusWatcher", action.type, action.payload);
      switch (action.type) {
        case authSuccessAction.type: {
          yield put2(sessionActions.connected(session.rpcConnectResult));
          sessionEmitter.emit("session.connected");
          break;
        }
        case authErrorAction.type: {
          yield fork2(sessionAuthErrorSaga, __spreadProps(__spreadValues({}, options), {
            action
          }));
          break;
        }
        case authExpiringAction.type: {
          sessionEmitter.emit("session.expiring");
          break;
        }
        case reauthAction.type: {
          yield fork2(reauthenticateWorker, {
            session,
            token: action.payload.token,
            sessionEmitter
          });
          break;
        }
        case sessionReconnectingAction.type: {
          sessionEmitter.emit("session.reconnecting");
          break;
        }
        case sessionForceCloseAction.type: {
          session.forceClose();
          break;
        }
      }
    }
  } finally {
    if (yield cancelled()) {
      getLogger().debug("sessionStatusWatcher [cancelled]");
    }
  }
}
function* sessionAuthErrorSaga(options) {
  getLogger().debug("sessionAuthErrorSaga [started]");
  try {
    const { action, sessionEmitter } = options;
    const { error: authError } = action.payload;
    const error = authError ? new AuthError(authError.code, authError.message) : new Error("Unauthorized");
    sessionEmitter.emit("session.auth_error", error);
  } finally {
    if (yield cancelled()) {
      getLogger().debug("sessionAuthErrorSaga [cancelled]");
    }
  }
}
var rootSaga_default = (options) => {
  return function* root({
    userOptions,
    channels
  }) {
    getLogger().debug("rootSaga [started]");
    if (userOptions.logger) {
      setLogger(userOptions.logger);
    }
    if (userOptions.debug) {
      setDebugOptions(userOptions.debug);
    }
    while (true) {
      yield take2(initAction.type);
      try {
        yield call2(sessionSaga, __spreadProps(__spreadValues({}, options), {
          userOptions,
          channels
        }));
        break;
      } catch (error) {
        getLogger().error("RootSaga Error:", error);
      } finally {
        if (yield cancelled()) {
          getLogger().debug("rootSaga [cancelled]");
        }
        getLogger().debug("Reboot rootSaga");
      }
    }
    getLogger().debug("rootSaga [finished]");
  };
};

// src/redux/features/session/sessionSelectors.ts
var sessionSelectors_exports = {};
__export(sessionSelectors_exports, {
  getAuthError: () => getAuthError,
  getAuthStatus: () => getAuthStatus,
  getAuthorization: () => getAuthorization,
  getAuthorizationState: () => getAuthorizationState,
  getIceServers: () => getIceServers,
  getProtocol: () => getProtocol,
  getSession: () => getSession
});
var getIceServers = ({ session }) => {
  var _a;
  return (_a = session == null ? void 0 : session.iceServers) != null ? _a : [];
};
var getSession = (store) => {
  return store.session;
};
var getAuthStatus = ({ session }) => {
  return session.authStatus;
};
var getAuthError = ({ session }) => {
  return session.authError;
};
var getAuthorization = ({ session }) => {
  return session.authorization;
};
var getAuthorizationState = ({ session }) => {
  return session.authorizationState;
};
var getProtocol = ({ session }) => {
  return session.protocol;
};

// src/redux/connect.ts
var connect = (options) => {
  const { sessionListeners = {}, store, Component, customSagas = [] } = options;
  const sessionKeys = Object.keys(sessionListeners);
  return (userOptions) => {
    const instance = new Component(__spreadProps(__spreadValues({}, userOptions), { store }));
    const cacheMap = /* @__PURE__ */ new Map();
    let run = true;
    const storeUnsubscribe = store.subscribe(() => {
      const state = store.getState();
      const session = getSession(state);
      for (const reduxKey of sessionKeys) {
        if (run === false) {
          return;
        }
        const cacheKey = `session.${reduxKey}`;
        const current = cacheMap.get(cacheKey);
        const updatedValue = session[reduxKey];
        if (updatedValue !== void 0 && current !== updatedValue) {
          cacheMap.set(cacheKey, updatedValue);
          const fnName = sessionListeners[reduxKey];
          if (typeof fnName === "string") {
            instance[fnName](session);
          } else if (typeof fnName === "function") {
            fnName(session);
          }
        }
      }
    });
    const taskList = customSagas == null ? void 0 : customSagas.map((saga) => {
      return store.runSaga(saga, { instance, runSaga: store.runSaga });
    });
    instance.destroyer = () => {
      run = false;
      storeUnsubscribe();
      cacheMap.clear();
      if (taskList == null ? void 0 : taskList.length) {
        taskList.forEach((task) => task.cancel());
      }
    };
    return instance;
  };
};

// src/utils/EventEmitter.ts
import EventEmitter from "eventemitter3";
var getEventEmitter = () => {
  return new EventEmitter();
};

// src/redux/utils/useSession.ts
var useSession = (options) => {
  const { SessionConstructor, userOptions, sessionChannel } = options;
  const sessionEmitter = getEventEmitter();
  let session = null;
  const initSession = () => {
    session = new SessionConstructor(__spreadProps(__spreadValues({}, userOptions), {
      sessionChannel
    }));
    return session;
  };
  const getSession2 = () => {
    if (!session) {
      getLogger().warn("Session does not exist!");
    }
    return session;
  };
  return { session, initSession, getSession: getSession2, sessionEmitter };
};

// src/redux/utils/useInstanceMap.ts
var useInstanceMap = () => {
  const instanceMap = /* @__PURE__ */ new Map();
  const getInstance = (key) => {
    return instanceMap.get(key);
  };
  const setInstance = (key, value) => {
    instanceMap.set(key, value);
    return instanceMap;
  };
  const deleteInstance = (key) => {
    instanceMap.delete(key);
    return instanceMap;
  };
  const getAllInstances = () => {
    return Array.from(instanceMap.entries());
  };
  const deleteAllInstances = () => {
    instanceMap.clear();
    return instanceMap;
  };
  return {
    get: getInstance,
    set: setInstance,
    remove: deleteInstance,
    getAll: getAllInstances,
    deleteAll: deleteAllInstances
  };
};

// src/redux/index.ts
__reExport(redux_exports, toolkit_exports);
var configureStore2 = (options) => {
  var _a;
  const {
    userOptions,
    SessionConstructor,
    preloadedState = {},
    runRootSaga = true
  } = options;
  const sagaMiddleware = createSagaMiddleware({
    // @ts-expect-error For testing purposes only
    sagaMonitor: userOptions.sagaMonitor
  });
  const swEventChannel = multicastChannel();
  const sessionChannel = channel();
  const channels = {
    swEventChannel,
    sessionChannel
  };
  const store = configureStore({
    devTools: (_a = userOptions == null ? void 0 : userOptions.devTools) != null ? _a : true,
    reducer: rootReducer,
    preloadedState,
    middleware: (getDefaultMiddleware) => (
      // It is preferrable to use the chainable .concat(...) and
      // .prepend(...) methods of the returned MiddlewareArray instead
      // of the array spread operator, as the latter can lose valuable
      // type information under some circumstances.
      // @see https://redux-toolkit.js.org/api/getDefaultMiddleware#intended-usage
      getDefaultMiddleware().concat(sagaMiddleware)
    )
  });
  const instanceMap = useInstanceMap();
  const { initSession, getSession: getSession2, sessionEmitter } = useSession({
    userOptions,
    sessionChannel,
    SessionConstructor
  });
  const runSaga = (saga, args) => {
    return sagaMiddleware.run(saga, __spreadProps(__spreadValues({}, args), {
      channels,
      getSession: getSession2,
      instanceMap
    }));
  };
  if (runRootSaga) {
    const saga = rootSaga_default({
      initSession,
      sessionEmitter
    });
    sagaMiddleware.run(saga, { userOptions, channels });
  }
  return __spreadProps(__spreadValues({}, store), {
    runSaga,
    channels,
    instanceMap,
    sessionEmitter
  });
};

// src/workers/executeActionWorker.ts
import { call as call3 } from "@redux-saga/core/effects";
var executeActionWorker = function* (options) {
  const { initialState, onDone, onFail, getSession: getSession2 } = options;
  const { requestId: id, method, params } = initialState;
  const session = getSession2();
  if (!session) {
    const error = new Error("Session does not exist!");
    getLogger().error(error);
    onFail == null ? void 0 : onFail(error);
    return;
  }
  try {
    let message = RPCExecute({ id, method, params });
    const response = yield call3(session.execute, message);
    onDone == null ? void 0 : onDone(response);
  } catch (error) {
    getLogger().warn("Execute error: ", error);
    onFail == null ? void 0 : onFail(error);
  }
};

// src/BaseComponent.ts
var identity = (payload) => payload;
var SW_SYMBOL2 = Symbol("BaseComponent");
var BaseComponent = class {
  constructor(options) {
    this.options = options;
    /** @internal */
    __publicField(this, "__sw_symbol", SW_SYMBOL2);
    /** @internal */
    __publicField(this, "uuid", v4());
    __publicField(this, "_customSagaTriggers", /* @__PURE__ */ new Map());
    __publicField(this, "_destroyer");
    __publicField(this, "eventEmitter");
    /**
     * List of running Tasks to be cancelled on `destroy`.
     */
    __publicField(this, "_runningWorkers", []);
    /**
     * Map of Sagas that will be attached to the Store to
     * handle events or perform side-effects. This Map will
     * behave as a queue and will be emptied once the workers
     * have been attached. See `this.attachWorkers` for
     * details.
     */
    __publicField(this, "_workers", /* @__PURE__ */ new Map());
    this.eventEmitter = new EventEmitter();
  }
  /** @internal */
  get __uuid() {
    return this.uuid;
  }
  get logger() {
    return getLogger();
  }
  /** @internal */
  set destroyer(d) {
    this._destroyer = d;
  }
  /** @internal */
  get store() {
    return this.options.store;
  }
  /** @internal */
  get instanceMap() {
    return this.store.instanceMap;
  }
  /** @internal */
  get emitter() {
    return this.eventEmitter;
  }
  /** @internal */
  get sessionEmitter() {
    return this.store.sessionEmitter;
  }
  /** @internal */
  get session() {
    return this.sessionEmitter;
  }
  on(event, fn) {
    return this.emitter.on(event, fn);
  }
  once(event, fn) {
    return this.emitter.once(event, fn);
  }
  off(event, fn) {
    return this.emitter.off(event, fn);
  }
  removeAllListeners(event) {
    if (event) {
      return this.off(event);
    }
    this.eventNames().forEach((eventName) => {
      this.off(eventName);
    });
    return this.emitter;
  }
  /** @internal */
  eventNames() {
    return this.emitter.eventNames();
  }
  /** @internal */
  sessionEventNames() {
    return this.sessionEmitter.eventNames();
  }
  getSubscriptions() {
    return validateEventsToSubscribe(this.eventNames());
  }
  /** @internal */
  emit(event, ...args) {
    return this.emitter.emit(event, ...args);
  }
  /** @internal */
  listenerCount(event) {
    return this.emitter.listenerCount(event);
  }
  destroy() {
    var _a;
    (_a = this._destroyer) == null ? void 0 : _a.call(this);
    this.removeAllListeners();
    this.detachWorkers();
  }
  /** @internal */
  execute({ method, params }, {
    transformParams = identity,
    transformResolve = identity,
    transformReject = identity
  } = {
    transformParams: identity,
    transformResolve: identity,
    transformReject: identity
  }) {
    return new Promise((resolve, reject) => {
      const requestId = v4();
      this.runWorker("executeActionWorker", {
        worker: executeActionWorker,
        onDone: (data) => resolve(transformResolve(data)),
        onFail: (error) => reject(transformReject(error)),
        initialState: {
          requestId,
          componentId: this.__uuid,
          method,
          params: transformParams(params)
        }
      });
    });
  }
  /** @internal */
  triggerCustomSaga(action) {
    return new Promise((resolve, reject) => {
      const dispatchId = v4();
      this._customSagaTriggers.set(dispatchId, { resolve, reject });
      this.store.dispatch(__spreadValues({
        dispatchId
      }, makeCustomSagaAction(this.__uuid, action)));
    });
  }
  /** @internal */
  settleCustomSagaTrigger({
    dispatchId,
    payload,
    kind
  }) {
    const actions = this._customSagaTriggers.get(dispatchId);
    if (actions) {
      actions[kind](payload);
      this._customSagaTriggers.delete(dispatchId);
    }
  }
  /** @internal */
  select(selectorFn) {
    return selectorFn(this.store.getState());
  }
  /** @internal */
  getStateProperty(param) {
    return this[param];
  }
  /** @internal */
  get _sessionAuthStatus() {
    return this.select(getAuthStatus);
  }
  /** @internal */
  get _sessionAuthorization() {
    return this.select(getAuthorization);
  }
  /** @internal */
  _waitUntilSessionAuthorized() {
    const authStatus = this._sessionAuthStatus;
    switch (authStatus) {
      case "authorized":
        return Promise.resolve(this);
      /**
       * `unknown` is the initial state of the auth reducer
       * so if we've got this far it means it's the first
       * time the user is calling `connect`.
       */
      case "unknown":
      /**
       * `authorizing` means that the user is calling
       * `connect` again while we're in the process of
       * authorizing the session.
       */
      case "authorizing":
        return new Promise((resolve, reject) => {
          const unsubscribe = this.store.subscribe(() => {
            const authStatus2 = this.select(getAuthStatus);
            const authError = this.select(getAuthError);
            if (authStatus2 === "authorized") {
              resolve(this);
              unsubscribe();
            } else if (authStatus2 === "unauthorized") {
              const error = authError ? new AuthError(authError.code, authError.message) : new Error("Unauthorized");
              reject(error);
              unsubscribe();
            }
          });
        });
      case "unauthorized":
        return Promise.reject(new Error("Unauthorized"));
    }
  }
  /** @internal */
  runWorker(name, def) {
    if (this._workers.has(name)) {
      getLogger().warn(
        `[runWorker] Worker with name ${name} has already been registerd.`
      );
    } else {
      this._setWorker(name, def);
    }
    return this._attachWorker(name, def);
  }
  cancelWorker(workerTask) {
    const foundTaskIndex = this._runningWorkers.findIndex(
      (task) => task === workerTask
    );
    if (foundTaskIndex > -1) {
      this._runningWorkers.splice(foundTaskIndex, 1);
      workerTask.cancel();
    }
  }
  _setWorker(name, def) {
    this._workers.set(name, def);
  }
  _attachWorker(name, _a) {
    var _b = _a, { worker } = _b, params = __objRest(_b, ["worker"]);
    const task = this.store.runSaga(worker, __spreadValues({
      instance: this,
      runSaga: this.store.runSaga
    }, params));
    this._runningWorkers.push(task);
    this._workers.delete(name);
    return task;
  }
  detachWorkers() {
    this._runningWorkers.forEach((task) => {
      task.cancel();
    });
    this._runningWorkers = [];
  }
};

// src/BaseClient.ts
var BaseClient = class extends BaseComponent {
  constructor(options) {
    super(options);
    this.options = options;
  }
  /**
   * Connect the underlay WebSocket connection to the SignalWire network.
   *
   * @returns Promise that will resolve with the Client object.
   */
  connect() {
    const authStatus = getAuthStatus(this.store.getState());
    if (authStatus === "unknown" || authStatus === "unauthorized") {
      this.store.dispatch(initAction());
    }
    return this._waitUntilSessionAuthorized();
  }
  /**
   * Disconnect the Client from the SignalWire network.
   */
  disconnect() {
    this.store.dispatch(destroyAction());
  }
  removeAllListeners(event) {
    this.sessionEventNames().forEach((eventName) => {
      this.sessionEmitter.off(eventName);
    });
    return super.removeAllListeners(event);
  }
};

// src/BaseConsumer.ts
var BaseConsumer = class extends BaseComponent {
  constructor(options) {
    super(options);
    this.options = options;
    __publicField(this, "subscribeMethod", "signalwire.subscribe");
    __publicField(this, "subscribeParams", {});
    __publicField(this, "_latestExecuteParams");
    const resetLatestExecuteParams = () => {
      this._latestExecuteParams = void 0;
    };
    super.session.on("session.connected", resetLatestExecuteParams);
    super.session.on("session.disconnected", resetLatestExecuteParams);
    super.session.on("session.reconnecting", resetLatestExecuteParams);
  }
  shouldExecuteSubscribe(execParams) {
    return !this._latestExecuteParams || JSON.stringify(execParams) !== JSON.stringify(this._latestExecuteParams);
  }
  async subscribe() {
    await this._waitUntilSessionAuthorized();
    const subscriptions = this.getSubscriptions();
    if (subscriptions.length === 0) {
      this.logger.debug(
        "`subscribe()` was called without any listeners attached."
      );
      return;
    }
    const execParams = {
      method: this.subscribeMethod,
      params: __spreadProps(__spreadValues({}, this.subscribeParams), {
        event_channel: this.getStateProperty("eventChannel"),
        events: subscriptions
      })
    };
    if (!this.shouldExecuteSubscribe(execParams)) {
      this.logger.debug(
        "BaseConsumer.subscribe() - Skipped .execute() since the execParams are exactly the same as last time"
      );
      return;
    }
    this._latestExecuteParams = execParams;
    return new Promise(async (resolve, reject) => {
      try {
        await this.execute(execParams);
        return resolve(void 0);
      } catch (error) {
        return reject(error);
      }
    });
  }
};

// src/types/videoMember.ts
var INTERNAL_MEMBER_UPDATABLE_PROPS = {
  audio_muted: true,
  video_muted: true,
  deaf: true,
  visible: true,
  input_volume: 1,
  output_volume: 1,
  input_sensitivity: 1
};
var INTERNAL_MEMBER_UPDATED_EVENTS = Object.keys(
  INTERNAL_MEMBER_UPDATABLE_PROPS
).map((key) => {
  return `${PRODUCT_PREFIX_VIDEO}.member.updated.${key}`;
});
var MEMBER_UPDATABLE_PROPS = toExternalJSON(
  INTERNAL_MEMBER_UPDATABLE_PROPS
);
var MEMBER_UPDATED_EVENTS = Object.keys(MEMBER_UPDATABLE_PROPS).map(
  (key) => {
    return `member.updated.${key}`;
  }
);

// src/redux/features/component/componentSelectors.ts
var componentSelectors_exports = {};
__export(componentSelectors_exports, {
  getComponent: () => getComponent,
  getComponentsById: () => getComponentsById,
  getComponentsToCleanup: () => getComponentsToCleanup
});
var getComponent = ({ components }, id) => {
  var _a;
  return (_a = components.byId) == null ? void 0 : _a[id];
};
var getComponentsById = ({ components }) => {
  return components.byId;
};
var getComponentsToCleanup = (state) => {
  const components = getComponentsById(state);
  let toCleanup = [];
  Object.keys(components).forEach((id) => {
    if (components[id].responses || components[id].errors) {
      toCleanup.push(id);
    }
  });
  return toCleanup;
};

// src/types/fabricMember.ts
var INTERNAL_FABRIC_MEMBER_UPDATABLE_PROPS = {
  audio_muted: true,
  video_muted: true,
  deaf: true,
  visible: true,
  input_volume: 1,
  output_volume: 1,
  input_sensitivity: 1,
  handraised: true,
  echo_cancellation: true,
  auto_gain: true,
  noise_suppression: true
};
var INTERNAL_FABRIC_MEMBER_UPDATED_EVENTS = Object.keys(
  INTERNAL_FABRIC_MEMBER_UPDATABLE_PROPS
).map((key) => {
  return `member.updated.${key}`;
});
var FABRIC_MEMBER_UPDATABLE_PROPS = toExternalJSON(INTERNAL_FABRIC_MEMBER_UPDATABLE_PROPS);
var FABRIC_MEMBER_UPDATED_EVENTS = Object.keys(
  FABRIC_MEMBER_UPDATABLE_PROPS
).map((key) => {
  return `member.updated.${key}`;
});

// src/index.ts
import * as sagaEffects from "@redux-saga/core/effects";

// src/rooms/index.ts
var rooms_exports = {};
__export(rooms_exports, {
  RoomSessionPlaybackAPI: () => RoomSessionPlaybackAPI,
  RoomSessionRecordingAPI: () => RoomSessionRecordingAPI,
  RoomSessionStreamAPI: () => RoomSessionStreamAPI,
  audioMuteMember: () => audioMuteMember,
  audioUnmuteMember: () => audioUnmuteMember,
  createRoomSessionPlaybackObject: () => createRoomSessionPlaybackObject,
  createRoomSessionRecordingObject: () => createRoomSessionRecordingObject,
  createRoomSessionStreamObject: () => createRoomSessionStreamObject,
  deafMember: () => deafMember,
  deleteMemberMeta: () => deleteMemberMeta,
  deleteMeta: () => deleteMeta,
  demote: () => demote,
  getLayouts: () => getLayouts,
  getMemberMeta: () => getMemberMeta,
  getMembers: () => getMembers,
  getMeta: () => getMeta,
  getPlaybacks: () => getPlaybacks,
  getRecordings: () => getRecordings,
  getStreams: () => getStreams,
  hideVideoMuted: () => hideVideoMuted,
  lock: () => lock,
  play: () => play,
  promote: () => promote,
  removeAllMembers: () => removeAllMembers,
  removeMember: () => removeMember,
  setDeaf: () => setDeaf,
  setHideVideoMuted: () => setHideVideoMuted,
  setInputSensitivityMember: () => setInputSensitivityMember,
  setInputVolumeMember: () => setInputVolumeMember,
  setLayout: () => setLayout,
  setMemberMeta: () => setMemberMeta,
  setMemberPosition: () => setMemberPosition,
  setMeta: () => setMeta,
  setOutputVolumeMember: () => setOutputVolumeMember,
  setPositions: () => setPositions,
  setPrioritizeHandraise: () => setPrioritizeHandraise,
  setRaisedHand: () => setRaisedHand,
  showVideoMuted: () => showVideoMuted,
  startRecording: () => startRecording,
  startStream: () => startStream,
  undeafMember: () => undeafMember,
  unlock: () => unlock,
  updateMemberMeta: () => updateMemberMeta,
  updateMeta: () => updateMeta,
  videoMuteMember: () => videoMuteMember,
  videoUnmuteMember: () => videoUnmuteMember
});

// src/rooms/methods.ts
var baseCodeTransform = () => {
};
var createRoomMethod = (method, options = {}) => ({
  value: function(params = {}) {
    return this.execute(
      {
        method,
        params: __spreadValues({
          room_session_id: this.roomSessionId
        }, params)
      },
      options
    );
  }
});
var createRoomMemberMethod = (method, options = {}) => ({
  value: function(_a = {}) {
    var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
    return this.execute(
      {
        method,
        params: __spreadValues({
          room_session_id: this.roomSessionId,
          member_id: memberId || this.memberId
        }, rest)
      },
      options
    );
  }
});
var getLayouts = createRoomMethod(
  "video.list_available_layouts",
  {
    transformResolve: (payload) => ({ layouts: payload.layouts })
  }
);
var getMembers = createRoomMethod(
  "video.members.get",
  {
    transformResolve: (payload) => ({ members: payload.members })
  }
);
var setLayout = createRoomMethod(
  "video.set_layout",
  {
    transformResolve: baseCodeTransform
  }
);
var setPositions = createRoomMethod(
  "video.set_position",
  {
    transformResolve: baseCodeTransform
  }
);
var hideVideoMuted = createRoomMethod(
  "video.hide_video_muted",
  {
    transformResolve: baseCodeTransform
  }
);
var showVideoMuted = createRoomMethod(
  "video.show_video_muted",
  {
    transformResolve: baseCodeTransform
  }
);
var lock = createRoomMethod("video.lock", {
  transformResolve: baseCodeTransform
});
var unlock = createRoomMethod("video.unlock", {
  transformResolve: baseCodeTransform
});
var setHideVideoMuted = {
  value: function(value) {
    return this.execute(
      {
        method: value ? "video.hide_video_muted" : "video.show_video_muted",
        params: {
          room_session_id: this.roomSessionId
        }
      },
      {
        transformResolve: baseCodeTransform
      }
    );
  }
};
var getRecordings = {
  value: function() {
    return new Promise(async (resolve, reject) => {
      try {
        const { recordings } = await this.execute({
          method: "video.recording.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const recordingInstances = [];
        recordings.forEach((recording) => {
          let recordingInstance = this.instanceMap.get(
            recording.id
          );
          if (!recordingInstance) {
            recordingInstance = createRoomSessionRecordingObject({
              store: this.store,
              payload: {
                room_id: this.roomId,
                room_session_id: this.roomSessionId,
                recording
              }
            });
          } else {
            recordingInstance.setPayload({
              room_id: this.roomId,
              room_session_id: this.roomSessionId,
              recording
            });
          }
          recordingInstances.push(recordingInstance);
          this.instanceMap.set(
            recordingInstance.id,
            recordingInstance
          );
        });
        resolve({ recordings: recordingInstances });
      } catch (error) {
        reject(error);
      }
    });
  }
};
var startRecording = {
  value: function() {
    return new Promise(async (resolve, reject) => {
      try {
        const { recording } = await this.execute({
          method: "video.recording.start",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const recordingInstance = createRoomSessionRecordingObject({
          store: this.store,
          payload: {
            room_id: this.roomId,
            room_session_id: this.roomSessionId,
            recording
          }
        });
        this.instanceMap.set(
          recordingInstance.id,
          recordingInstance
        );
        resolve(recordingInstance);
      } catch (error) {
        reject(error);
      }
    });
  }
};
var getPlaybacks = {
  value: function() {
    return new Promise(async (resolve, reject) => {
      try {
        const { playbacks } = await this.execute({
          method: "video.playback.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const playbackInstances = [];
        playbacks.forEach((playback) => {
          let playbackInstance = this.instanceMap.get(
            playback.id
          );
          if (!playbackInstance) {
            playbackInstance = createRoomSessionPlaybackObject({
              store: this.store,
              payload: {
                room_id: this.roomId,
                room_session_id: this.roomSessionId,
                playback
              }
            });
          } else {
            playbackInstance.setPayload({
              room_id: this.roomId,
              room_session_id: this.roomSessionId,
              playback
            });
          }
          playbackInstances.push(playbackInstance);
          this.instanceMap.set(
            playbackInstance.id,
            playbackInstance
          );
        });
        resolve({ playbacks: playbackInstances });
      } catch (error) {
        reject(error);
      }
    });
  }
};
var play = {
  value: function(_a) {
    var _b = _a, { seekPosition, currentTimecode } = _b, params = __objRest(_b, ["seekPosition", "currentTimecode"]);
    return new Promise(async (resolve, reject) => {
      try {
        const seek_position = seekPosition || currentTimecode;
        const { playback } = await this.execute({
          method: "video.playback.start",
          params: __spreadValues({
            room_session_id: this.roomSessionId,
            seek_position
          }, params)
        });
        const playbackInstance = createRoomSessionPlaybackObject({
          store: this.store,
          payload: {
            room_id: this.roomId,
            room_session_id: this.roomSessionId,
            playback
          }
        });
        this.instanceMap.set(
          playbackInstance.id,
          playbackInstance
        );
        resolve(playbackInstance);
      } catch (error) {
        reject(error);
      }
    });
  }
};
var createRoomMetaMethod = (method) => {
  return createRoomMethod(method, {
    transformResolve: baseCodeTransform,
    transformParams: (params) => {
      const _a = params, { room_session_id } = _a, meta = __objRest(_a, ["room_session_id"]);
      return { room_session_id, meta };
    }
  });
};
var getMeta = createRoomMethod("video.get_meta", {
  transformResolve: ({ meta }) => ({ meta })
});
var setMeta = createRoomMetaMethod("video.set_meta");
var updateMeta = createRoomMetaMethod("video.update_meta");
var deleteMeta = {
  value: function(params) {
    return this.execute({
      method: "video.delete_meta",
      params: {
        room_session_id: this.roomSessionId,
        keys: params
      }
    });
  }
};
var getStreams = {
  value: function() {
    return new Promise(async (resolve, reject) => {
      try {
        const { streams } = await this.execute({
          method: "video.stream.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        const streamInstances = [];
        streams.forEach((stream) => {
          let streamInstance = this.instanceMap.get(
            stream.id
          );
          if (!streamInstance) {
            streamInstance = createRoomSessionStreamObject({
              store: this.store,
              payload: {
                room_id: this.roomId,
                room_session_id: this.roomSessionId,
                stream
              }
            });
          } else {
            streamInstance.setPayload({
              room_id: this.roomId,
              room_session_id: this.roomSessionId,
              stream
            });
          }
          streamInstances.push(streamInstance);
          this.instanceMap.set(
            streamInstance.id,
            streamInstance
          );
        });
        resolve({ streams: streamInstances });
      } catch (error) {
        reject(error);
      }
    });
  }
};
var startStream = {
  value: function(params) {
    return new Promise(async (resolve, reject) => {
      try {
        const { stream } = await this.execute({
          method: "video.stream.start",
          params: __spreadValues({
            room_session_id: this.roomSessionId
          }, params)
        });
        const streamInstance = createRoomSessionStreamObject({
          store: this.store,
          payload: {
            room_id: this.roomId,
            room_session_id: this.roomSessionId,
            stream
          }
        });
        this.instanceMap.set(
          streamInstance.id,
          streamInstance
        );
        resolve({ stream: streamInstance });
      } catch (error) {
        reject(error);
      }
    });
  }
};
var setPrioritizeHandraise = {
  value: function(params) {
    return this.execute({
      method: "video.prioritize_handraise",
      params: {
        room_session_id: this.roomSessionId,
        enable: params
      }
    });
  }
};
var audioMuteMember = createRoomMemberMethod(
  "video.member.audio_mute",
  {
    transformResolve: baseCodeTransform
  }
);
var audioUnmuteMember = createRoomMemberMethod(
  "video.member.audio_unmute",
  {
    transformResolve: baseCodeTransform
  }
);
var videoMuteMember = createRoomMemberMethod(
  "video.member.video_mute",
  {
    transformResolve: baseCodeTransform
  }
);
var videoUnmuteMember = createRoomMemberMethod(
  "video.member.video_unmute",
  {
    transformResolve: baseCodeTransform
  }
);
var deafMember = createRoomMemberMethod(
  "video.member.deaf",
  {
    transformResolve: baseCodeTransform
  }
);
var undeafMember = createRoomMemberMethod(
  "video.member.undeaf",
  {
    transformResolve: baseCodeTransform
  }
);
var setDeaf = {
  value: function(value) {
    return this.execute(
      {
        method: value ? "video.member.deaf" : "video.member.undeaf",
        params: {
          room_session_id: this.roomSessionId,
          member_id: this.memberId
        }
      },
      {
        transformResolve: baseCodeTransform
      }
    );
  }
};
var setInputVolumeMember = createRoomMemberMethod(
  "video.member.set_input_volume",
  {
    transformResolve: baseCodeTransform
  }
);
var setOutputVolumeMember = createRoomMemberMethod("video.member.set_output_volume", {
  transformResolve: baseCodeTransform
});
var setInputSensitivityMember = createRoomMemberMethod("video.member.set_input_sensitivity", {
  transformResolve: baseCodeTransform
});
var promote = {
  value: function(_a) {
    var _b = _a, {
      memberId,
      mediaAllowed,
      joinAudioMuted,
      joinVideoMuted
    } = _b, rest = __objRest(_b, [
      "memberId",
      "mediaAllowed",
      "joinAudioMuted",
      "joinVideoMuted"
    ]);
    return this.execute(
      {
        method: "video.member.promote",
        params: __spreadValues({
          room_session_id: this.roomSessionId,
          member_id: memberId,
          media_allowed: mediaAllowed,
          join_audio_muted: joinAudioMuted,
          join_video_muted: joinVideoMuted
        }, rest)
      },
      {
        transformResolve: baseCodeTransform
      }
    );
  }
};
var demote = {
  value: function({ memberId, mediaAllowed }) {
    return this.execute(
      {
        method: "video.member.demote",
        params: {
          room_session_id: this.roomSessionId,
          member_id: memberId,
          media_allowed: mediaAllowed
        }
      },
      {
        transformResolve: baseCodeTransform
      }
    );
  }
};
var setMemberPosition = createRoomMemberMethod(
  "video.member.set_position",
  {
    transformResolve: baseCodeTransform
  }
);
var removeMember = {
  value: function(_a) {
    var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
    if (!memberId) {
      throw new TypeError('Invalid or missing "memberId" argument');
    }
    return this.execute(
      {
        method: "video.member.remove",
        params: __spreadValues({
          room_session_id: this.roomSessionId,
          member_id: memberId
        }, rest)
      },
      {
        transformResolve: baseCodeTransform
      }
    );
  }
};
var removeAllMembers = {
  value: function() {
    return this.execute(
      {
        method: "video.member.remove",
        params: {
          room_session_id: this.roomSessionId,
          member_id: "all"
        }
      },
      {
        transformResolve: baseCodeTransform
      }
    );
  }
};
var getMemberMeta = createRoomMemberMethod("video.member.get_meta", {
  transformResolve: ({ meta }) => ({ meta })
});
var setMemberMeta = createRoomMemberMethod(
  "video.member.set_meta",
  {
    transformResolve: baseCodeTransform
  }
);
var updateMemberMeta = createRoomMemberMethod(
  "video.member.update_meta",
  {
    transformResolve: baseCodeTransform
  }
);
var deleteMemberMeta = createRoomMemberMethod(
  "video.member.delete_meta",
  {
    transformResolve: baseCodeTransform
  }
);
var setRaisedHand = {
  value: function(value) {
    const { raised = true, memberId = this.memberId } = value || {};
    if (!memberId) {
      throw new TypeError('Invalid or missing "memberId" argument');
    }
    return this.execute(
      {
        method: raised ? "video.member.raisehand" : "video.member.lowerhand",
        params: {
          room_session_id: this.roomSessionId,
          member_id: memberId
        }
      },
      {
        transformResolve: baseCodeTransform
      }
    );
  }
};

// src/rooms/RoomSessionRecording.ts
var RoomSessionRecordingAPI = class extends BaseComponent {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    this._payload = options.payload;
  }
  get id() {
    return this._payload.recording.id;
  }
  get roomId() {
    return this._payload.room_id;
  }
  get roomSessionId() {
    return this._payload.room_session_id;
  }
  get state() {
    return this._payload.recording.state;
  }
  get duration() {
    return this._payload.recording.duration;
  }
  get startedAt() {
    if (!this._payload.recording.started_at) return void 0;
    return new Date(
      this._payload.recording.started_at * 1e3
    );
  }
  get endedAt() {
    if (!this._payload.recording.ended_at) return void 0;
    return new Date(
      this._payload.recording.ended_at * 1e3
    );
  }
  /** @internal */
  setPayload(payload) {
    this._payload = payload;
  }
  async pause() {
    await this.execute({
      method: "video.recording.pause",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        recording_id: this.getStateProperty("id")
      }
    });
  }
  async resume() {
    await this.execute({
      method: "video.recording.resume",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        recording_id: this.getStateProperty("id")
      }
    });
  }
  async stop() {
    await this.execute({
      method: "video.recording.stop",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        recording_id: this.getStateProperty("id")
      }
    });
  }
};
var createRoomSessionRecordingObject = (params) => {
  const recording = connect({
    store: params.store,
    Component: RoomSessionRecordingAPI
  })(params);
  return recording;
};

// src/rooms/RoomSessionPlayback.ts
var RoomSessionPlaybackAPI = class extends BaseComponent {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    this._payload = options.payload;
  }
  get id() {
    return this._payload.playback.id;
  }
  get roomId() {
    return this._payload.room_id;
  }
  get roomSessionId() {
    return this._payload.room_session_id;
  }
  get url() {
    return this._payload.playback.url;
  }
  get state() {
    return this._payload.playback.state;
  }
  get volume() {
    return this._payload.playback.volume;
  }
  get startedAt() {
    if (!this._payload.playback.started_at) return void 0;
    return new Date(
      this._payload.playback.started_at * 1e3
    );
  }
  get endedAt() {
    if (!this._payload.playback.ended_at) return void 0;
    return new Date(
      this._payload.playback.ended_at * 1e3
    );
  }
  get position() {
    return this._payload.playback.position;
  }
  get seekable() {
    return this._payload.playback.seekable;
  }
  /** @internal */
  setPayload(payload) {
    this._payload = payload;
  }
  async pause() {
    await this.execute({
      method: "video.playback.pause",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        playback_id: this.getStateProperty("id")
      }
    });
  }
  async resume() {
    await this.execute({
      method: "video.playback.resume",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        playback_id: this.getStateProperty("id")
      }
    });
  }
  async stop() {
    await this.execute({
      method: "video.playback.stop",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        playback_id: this.getStateProperty("id")
      }
    });
  }
  async setVolume(volume) {
    await this.execute({
      method: "video.playback.set_volume",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        playback_id: this.getStateProperty("id"),
        volume
      }
    });
  }
  async seek(timecode) {
    await this.execute({
      method: "video.playback.seek_absolute",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        playback_id: this.getStateProperty("id"),
        position: Math.abs(timecode)
      }
    });
  }
  async forward(offset = 5e3) {
    await this.execute({
      method: "video.playback.seek_relative",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        playback_id: this.getStateProperty("id"),
        position: Math.abs(offset)
      }
    });
  }
  async rewind(offset = 5e3) {
    await this.execute({
      method: "video.playback.seek_relative",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        playback_id: this.getStateProperty("id"),
        position: -Math.abs(offset)
      }
    });
  }
};
var createRoomSessionPlaybackObject = (params) => {
  const playback = connect({
    store: params.store,
    Component: RoomSessionPlaybackAPI
  })(params);
  return playback;
};

// src/rooms/RoomSessionStream.ts
var RoomSessionStreamAPI = class extends BaseComponent {
  constructor(options) {
    super(options);
    __publicField(this, "_payload");
    this._payload = options.payload;
  }
  get id() {
    return this._payload.stream.id;
  }
  get roomId() {
    return this._payload.room_id;
  }
  get roomSessionId() {
    return this._payload.room_session_id;
  }
  get state() {
    return this._payload.stream.state;
  }
  get duration() {
    return this._payload.stream.duration;
  }
  get url() {
    return this._payload.stream.url;
  }
  get startedAt() {
    if (!this._payload.stream.started_at) return void 0;
    return new Date(
      this._payload.stream.started_at * 1e3
    );
  }
  get endedAt() {
    if (!this._payload.stream.ended_at) return void 0;
    return new Date(this._payload.stream.ended_at * 1e3);
  }
  /** @internal */
  setPayload(payload) {
    this._payload = payload;
  }
  async stop() {
    await this.execute({
      method: "video.stream.stop",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        stream_id: this.getStateProperty("id")
      }
    });
  }
};
var createRoomSessionStreamObject = (params) => {
  const stream = connect({
    store: params.store,
    Component: RoomSessionStreamAPI
  })(params);
  return stream;
};

// src/chat/index.ts
var chat_exports = {};
__export(chat_exports, {
  BaseChatAPI: () => BaseChatAPI,
  BaseChatConsumer: () => BaseChatConsumer,
  ChatMember: () => ChatMember,
  ChatMessage: () => ChatMessage,
  applyCommonMethods: () => applyCommonMethods,
  createBaseChatObject: () => createBaseChatObject,
  getMemberState: () => getMemberState,
  getMembers: () => getMembers2,
  getMessages: () => getMessages,
  publish: () => publish,
  setMemberState: () => setMemberState
});

// src/chat/utils/toInternalChatChannels.ts
var toInternalChatChannels = (channels) => {
  const list = !channels || Array.isArray(channels) ? channels : [channels];
  if (Array.isArray(list)) {
    return list.map((name) => {
      return {
        name
      };
    });
  }
  return [];
};

// src/chat/utils/index.ts
var isValidChannels = (input) => {
  return Array.isArray(input) || typeof input === "string";
};

// src/chat/methods.ts
var baseCodeTransform2 = () => {
};
var createChatMethod = (method, options = {}) => ({
  value: function(params = {}) {
    return this.execute(
      {
        method,
        params
      },
      options
    );
  }
});
var createChatMemberMethod = (method, options = {}) => ({
  value: function(_a = {}) {
    var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
    return this.execute(
      {
        method,
        params: __spreadValues({
          member_id: memberId
        }, rest)
      },
      options
    );
  }
});
var publish = createChatMethod("chat.publish", {
  transformResolve: baseCodeTransform2
});
var getMessages = createChatMethod("chat.messages.get", {
  transformResolve: (payload) => ({
    messages: payload.messages.map((message) => toExternalJSON(message)),
    cursor: payload.cursor
  })
});
var getMembers2 = createChatMethod(
  "chat.members.get",
  {
    transformResolve: (payload) => ({
      members: payload.members.map((member) => toExternalJSON(member))
    })
  }
);
var transformParamChannels = (params) => {
  const channels = isValidChannels(params == null ? void 0 : params.channels) ? toInternalChatChannels(params.channels) : void 0;
  return __spreadProps(__spreadValues({}, params), {
    channels
  });
};
var setMemberState = createChatMemberMethod(
  "chat.member.set_state",
  {
    transformResolve: baseCodeTransform2,
    transformParams: transformParamChannels
  }
);
var getMemberState = createChatMemberMethod("chat.member.get_state", {
  transformResolve: (payload) => ({ channels: payload.channels }),
  transformParams: transformParamChannels
});

// src/pubSub/index.ts
var pubSub_exports = {};
__export(pubSub_exports, {
  BasePubSubConsumer: () => BasePubSubConsumer,
  PubSubMessage: () => PubSubMessage,
  createBasePubSubObject: () => createBasePubSubObject
});

// src/pubSub/workers/pubSubWorker.ts
var pubSubWorker = function* (options) {
  getLogger().trace("pubSubWorker started");
  const {
    instance: client,
    channels: { swEventChannel }
  } = options;
  function* worker(action) {
    const { type, payload } = action;
    switch (type) {
      case `${PRODUCT_PREFIX_PUBSUB}.channel.message`: {
        const {
          channel: channel3,
          message: _a
        } = payload, _b = _a, { member } = _b, restMessage = __objRest(_b, ["member"]);
        const externalJSON = toExternalJSON(__spreadProps(__spreadValues({}, restMessage), {
          channel: channel3
        }));
        const pubSubMessage = new PubSubMessage(externalJSON);
        client.emit("message", pubSubMessage);
        break;
      }
      default:
        getLogger().warn(`Unknown pubsub event: "${type}"`);
        break;
    }
  }
  const isPubSubEvent = (action) => action.type.startsWith(`${PRODUCT_PREFIX_PUBSUB}.`);
  while (true) {
    const action = yield sagaEffects.take(
      swEventChannel,
      isPubSubEvent
    );
    yield sagaEffects.fork(worker, action);
  }
  getLogger().trace("pubSubWorker ended");
};

// src/pubSub/BasePubSub.ts
var toInternalPubSubChannels = (channels) => {
  return channels.map((name) => {
    return {
      name
    };
  });
};
var BasePubSubConsumer = class extends BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "subscribeMethod", `${PRODUCT_PREFIX_PUBSUB}.subscribe`);
    this.initWorker();
  }
  initWorker() {
    this.runWorker("pubSub", { worker: pubSubWorker });
  }
  _getChannelsParam(channels, method) {
    const _channels = !channels || Array.isArray(channels) ? channels : [channels];
    if (!Array.isArray(_channels) || _channels.length === 0) {
      throw new Error(
        `Please specify one or more channels when calling .${method}()`
      );
    }
    return {
      channels: toInternalPubSubChannels(_channels)
    };
  }
  /** @internal */
  _setSubscribeParams(params) {
    this.subscribeParams = __spreadValues(__spreadValues({}, this.subscribeParams), params);
  }
  /** @internal */
  _getSubscribeParams({ channels }) {
    return __spreadValues({}, this._getChannelsParam(channels, "subscribe"));
  }
  /** @internal */
  _getUnsubscribeParams({ channels }) {
    const channelsParam = this._getChannelsParam(channels, "unsubscribe");
    return __spreadValues({}, channelsParam);
  }
  _checkMissingSubscriptions() {
    const subscriptions = this.getSubscriptions();
    if (subscriptions.length === 0) {
      this.logger.info(
        "Subscribe was called before any listeners were attached. Move `.subscribe()` right after your event listeners to suppress this message."
      );
      this.once("message", () => {
      });
    }
  }
  /** @internal */
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map(
      (event) => `${PRODUCT_PREFIX_PUBSUB}.${String(event)}`
    );
    return validateEventsToSubscribe(eventNamesWithPrefix);
  }
  async subscribe(channels) {
    this._checkMissingSubscriptions();
    const params = this._getSubscribeParams({ channels });
    this._setSubscribeParams(params);
    return super.subscribe();
  }
  async unsubscribe(channels) {
    if (this._sessionAuthStatus === "unknown" || this._sessionAuthStatus === "unauthorized") {
      throw new Error("You must be authenticated to unsubscribe from a channel");
    }
    const params = this._getUnsubscribeParams({ channels });
    return new Promise(async (resolve, reject) => {
      const subscriptions = this.getSubscriptions();
      if (subscriptions.length > 0) {
        const execParams = {
          method: `${PRODUCT_PREFIX_PUBSUB}.unsubscribe`,
          params: __spreadProps(__spreadValues({}, params), {
            events: subscriptions
          })
        };
        try {
          await this.execute(execParams);
        } catch (error) {
          return reject(error);
        }
      } else {
        this.logger.warn(
          "`unsubscribe()` was called without any listeners attached."
        );
      }
      return resolve();
    });
  }
  // Currently only `js` supports this features and it's
  // being ignored (filtered at the Proxy level) within
  // `realtime-api`
  updateToken(token) {
    return new Promise((resolve, reject) => {
      this.session.once("session.auth_error", (error) => {
        reject(error);
      });
      this.session.once("session.connected", () => {
        resolve();
      });
      this.store.dispatch(actions_exports.reauthAction({ token }));
    });
  }
  publish(params) {
    return this.execute({
      method: `${PRODUCT_PREFIX_PUBSUB}.publish`,
      params
    });
  }
  // Currently only `js` supports this features and it's
  // being ignored (filtered at the Proxy level) within
  // `realtime-api`
  async getAllowedChannels() {
    await this._waitUntilSessionAuthorized();
    const authorization = this.select(getAuthorization);
    if (authorization && "channels" in authorization && authorization.channels) {
      return authorization.channels;
    }
    return {};
  }
};
var createBasePubSubObject = (params) => {
  const pubSub = connect({
    store: params.store,
    Component: BasePubSubConsumer
  })(params);
  return pubSub;
};

// src/pubSub/PubSubMessage.ts
var PubSubMessage = class {
  constructor(payload) {
    this.payload = payload;
  }
  /** The id of this message */
  get id() {
    return this.payload.id;
  }
  /** The channel in which this message was sent */
  get channel() {
    return this.payload.channel;
  }
  /** The content of this message */
  get content() {
    return this.payload.content;
  }
  /** Any metadata associated to this message */
  get meta() {
    return this.payload.meta;
  }
  /** The date at which this message was published */
  get publishedAt() {
    return this.payload.publishedAt;
  }
};

// src/chat/workers/chatWorker.ts
var chatWorker = function* (options) {
  getLogger().trace("chatWorker started");
  const {
    instance: client,
    channels: { swEventChannel }
  } = options;
  function* worker(action) {
    const { type, payload } = action;
    switch (type) {
      case "chat.channel.message": {
        const { channel: channel3, message } = payload;
        const externalJSON = toExternalJSON(__spreadProps(__spreadValues({}, message), {
          channel: channel3
        }));
        const chatMessage = new ChatMessage(externalJSON);
        client.emit("message", chatMessage);
        break;
      }
      case "chat.member.joined":
      case "chat.member.updated":
      case "chat.member.left": {
        const { member } = payload;
        const externalJSON = toExternalJSON(member);
        const chatMessage = new ChatMember(externalJSON);
        const event = stripNamespacePrefix(type);
        client.emit(event, chatMessage);
        break;
      }
      default:
        getLogger().warn(`Unknown chat event: "${type}"`);
        break;
    }
  }
  const isChatEvent = (action) => action.type.startsWith("chat.");
  while (true) {
    const action = yield sagaEffects.take(
      swEventChannel,
      isChatEvent
    );
    yield sagaEffects.fork(worker, action);
  }
  getLogger().trace("chatWorker ended");
};

// src/chat/BaseChat.ts
var BaseChatConsumer = class extends BasePubSubConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "subscribeMethod", `${PRODUCT_PREFIX_CHAT}.subscribe`);
  }
  initWorker() {
    this.runWorker("chat", { worker: chatWorker });
  }
};
var BaseChatAPI = extendComponent(
  BaseChatConsumer,
  {
    publish,
    getMembers: getMembers2,
    getMessages,
    setMemberState,
    getMemberState
  }
);
var createBaseChatObject = (params) => {
  const chat = connect({
    store: params.store,
    Component: BaseChatAPI
  })(params);
  return chat;
};

// src/chat/ChatMessage.ts
var ChatMessage = class extends PubSubMessage {
  /** The member which sent this message */
  get member() {
    return this.payload.member;
  }
};

// src/chat/ChatMember.ts
var ChatMember = class {
  constructor(payload) {
    this.payload = payload;
  }
  /** The id of this member */
  get id() {
    return this.payload.id;
  }
  /** The channel of this member */
  get channel() {
    return this.payload.channel;
  }
  /** The state of this member */
  get state() {
    var _a;
    return (_a = this.payload.state) != null ? _a : {};
  }
};

// src/chat/applyCommonMethods.ts
var transformParamChannels2 = (params) => {
  const channels = isValidChannels(params == null ? void 0 : params.channels) ? toInternalChatChannels(params.channels) : void 0;
  return __spreadProps(__spreadValues({}, params), {
    channels
  });
};
var baseCodeTransform3 = () => {
};
function applyCommonMethods(targetClass) {
  return class extends targetClass {
    getMembers(params) {
      return this._client.execute(
        {
          method: "chat.members.get",
          params
        },
        {
          transformResolve: (payload) => ({
            members: payload.members.map((member) => toExternalJSON(member))
          })
        }
      );
    }
    getMessages(params) {
      return this._client.execute(
        {
          method: "chat.messages.get",
          params
        },
        {
          transformResolve: (payload) => ({
            messages: payload.messages.map(
              (message) => toExternalJSON(message)
            ),
            cursor: payload.cursor
          })
        }
      );
    }
    setMemberState(_a = {}) {
      var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
      return this._client.execute(
        {
          method: "chat.member.set_state",
          params: __spreadValues({
            member_id: memberId
          }, rest)
        },
        {
          transformResolve: baseCodeTransform3,
          transformParams: transformParamChannels2
        }
      );
    }
    getMemberState(_c = {}) {
      var _d = _c, { memberId } = _d, rest = __objRest(_d, ["memberId"]);
      return this._client.execute(
        {
          method: "chat.member.get_state",
          params: __spreadValues({
            member_id: memberId
          }, rest)
        },
        {
          transformResolve: (payload) => ({
            channels: payload.channels
          }),
          transformParams: transformParamChannels2
        }
      );
    }
  };
}

// src/memberPosition/index.ts
var memberPosition_exports = {};
__export(memberPosition_exports, {
  memberPositionWorker: () => memberPositionWorker,
  memberUpdatedWorker: () => memberUpdatedWorker
});

// src/memberPosition/workers.ts
import { fork as fork3 } from "@redux-saga/core/effects";
var defaultDispatcher = function* (type, payload, instance) {
  const event = stripNamespacePrefix(type);
  instance.emit(event, payload);
};
function* memberPositionLayoutChangedWorker(options) {
  const {
    action,
    memberList,
    instance,
    dispatcher = defaultDispatcher
  } = options;
  const layers = action.payload.layout.layers;
  const processedMembers = {};
  layers.forEach((layer) => {
    var _a;
    const memberId = layer.member_id;
    if (!memberId) {
      return;
    }
    const memberEventParams = memberList.get(memberId);
    if (memberEventParams && layer.position !== ((_a = memberEventParams.member) == null ? void 0 : _a.current_position)) {
      mutateMemberCurrentPosition({
        memberList,
        memberId,
        currentPosition: layer.position
      });
      processedMembers[memberId] = true;
    } else {
      processedMembers[memberId] = false;
    }
  });
  for (const [memberId, payload] of memberList) {
    if (processedMembers[memberId]) {
      yield dispatcher == null ? void 0 : dispatcher("video.member.updated", payload, instance);
    } else if (processedMembers[memberId] === void 0) {
      const updatedMemberEventParams = mutateMemberCurrentPosition({
        memberList,
        memberId,
        currentPosition: "off-canvas"
      });
      if (!updatedMemberEventParams) {
        return;
      }
      yield dispatcher == null ? void 0 : dispatcher(
        "video.member.updated",
        updatedMemberEventParams,
        instance
      );
    }
  }
}
function* memberUpdatedWorker({
  action,
  memberList,
  instance,
  dispatcher = defaultDispatcher
}) {
  var _a, _b;
  const memberId = action.payload.member.id;
  const updatedMemberEventParams = mutateMemberCurrentPosition({
    memberList,
    memberId,
    currentPosition: (_b = (_a = memberList.get(memberId)) == null ? void 0 : _a.member) == null ? void 0 : _b.current_position
  });
  if (!updatedMemberEventParams) {
    return;
  }
  const {
    member: { updated = [] }
  } = action.payload;
  const memberUpdatedPayload = __spreadProps(__spreadValues({}, updatedMemberEventParams), {
    member: __spreadValues(__spreadValues({}, updatedMemberEventParams.member), action.payload.member)
  });
  memberList.set(memberId, memberUpdatedPayload);
  for (const key of updated) {
    const type = `${action.type}.${key}`;
    yield dispatcher == null ? void 0 : dispatcher(type, memberUpdatedPayload, instance);
  }
  yield dispatcher == null ? void 0 : dispatcher(action.type, memberUpdatedPayload, instance);
}
var memberPositionWorker = function* memberPositionWorker2({
  instance,
  channels,
  initialState,
  getSession: getSession2,
  instanceMap,
  dispatcher = defaultDispatcher
}) {
  if (!initialState) {
    return;
  }
  const { swEventChannel } = channels;
  let memberList = initializeMemberList(initialState);
  const addToMemberList = (payload) => {
    if (!memberList.has(payload.member.id)) {
      memberList.set(payload.member.id, payload);
    }
  };
  while (true) {
    const action = yield sagaEffects.take(
      swEventChannel,
      (action2) => {
        const istargetEvent = action2.type === "video.member.joined" || action2.type === "video.member.updated" || action2.type === "video.member.left" || action2.type === "video.layout.changed";
        return istargetEvent;
      }
    );
    switch (action.type) {
      case "video.member.joined": {
        addToMemberList(action.payload);
        break;
      }
      case "video.member.updated": {
        addToMemberList(action.payload);
        yield fork3(memberUpdatedWorker, {
          action,
          channels,
          memberList,
          instance,
          getSession: getSession2,
          instanceMap,
          dispatcher
        });
        break;
      }
      case "video.member.left": {
        const member = action.payload.member;
        memberList.delete(member.id);
        break;
      }
      case "video.layout.changed": {
        yield fork3(memberPositionLayoutChangedWorker, {
          action,
          channels,
          memberList,
          instance,
          dispatcher
        });
        break;
      }
    }
  }
};
var mutateMemberCurrentPosition = ({
  memberList,
  memberId,
  currentPosition
}) => {
  const memberEventParams = memberList.get(memberId);
  if (!memberEventParams) {
    return;
  } else if (!currentPosition) {
    return memberEventParams;
  }
  const updatedMemberEventParams = __spreadProps(__spreadValues({}, memberEventParams), {
    member: __spreadProps(__spreadValues({}, memberEventParams == null ? void 0 : memberEventParams.member), {
      current_position: currentPosition
    })
  });
  memberList.set(memberId, updatedMemberEventParams);
  return updatedMemberEventParams;
};
var initializeMemberList = (payload) => {
  const members = payload.room_session.members;
  const memberList = /* @__PURE__ */ new Map();
  members.forEach((member) => {
    const memberId = member.id;
    const roomSessionId = payload.room_session.id || payload.room_session.room_session_id;
    memberList.set(memberId, {
      room_id: payload.room_session.room_id,
      room_session_id: roomSessionId,
      member
    });
  });
  return memberList;
};

// src/testUtils.ts
var testUtils_exports = {};
__export(testUtils_exports, {
  configureFullStack: () => configureFullStack,
  configureJestStore: () => configureJestStore,
  createMockedLogger: () => createMockedLogger,
  createSessionChannel: () => createSessionChannel,
  createSwEventChannel: () => createSwEventChannel,
  rpcConnectResultVRT: () => rpcConnectResultVRT,
  wait: () => wait
});
import { channel as channel2, multicastChannel as multicastChannel2 } from "@redux-saga/core";
var PROJECT_ID = "8f0a119a-cda7-4497-a47d-c81493b824d4";
var TOKEN = "<VRT>";
var createMockedLogger = () => ({
  fatal: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  info: jest.fn(),
  debug: jest.fn(),
  trace: jest.fn(),
  wsTraffic: jest.fn()
});
var configureJestStore = (options) => {
  return configureStore2(__spreadValues({
    userOptions: {
      project: PROJECT_ID,
      token: TOKEN,
      devTools: false
    },
    SessionConstructor: BaseSession,
    runRootSaga: false
  }, options));
};
var configureFullStack = () => {
  const session = {
    dispatch: console.log,
    connect: jest.fn(),
    disconnect: jest.fn(),
    execute: jest.fn()
  };
  const emitter = new EventEmitter();
  const store = configureStore2({
    userOptions: {
      project: PROJECT_ID,
      token: TOKEN,
      devTools: false
    },
    SessionConstructor: jest.fn().mockImplementation(() => {
      return session;
    })
  });
  store.dispatch(actions_exports.initAction());
  store.dispatch(actions_exports.authSuccessAction());
  return {
    store,
    session,
    emitter,
    destroy: () => store.dispatch(actions_exports.destroyAction())
  };
};
var wait = (ms) => {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
};
var rpcConnectResultVRT = {
  identity: "f3bc99df-2c3d-4fa4-b1dc-e8a8ffc579e6@e3fefa44-1bad-4be9-ad9b-1cbb9abd60c7.west-us",
  authorization: {
    type: "video",
    project_id: "8f0a119a-cda7-4497-a47d-c81493b824d4",
    project: "8f0a119a-cda7-4497-a47d-c81493b824d4",
    scopes: ["video"],
    scope_id: "26675883-8499-4ee9-85eb-691c4aa209f8",
    resource: "9c80f1e8-9430-4070-a043-937eb3a96b38",
    join_as: "member",
    user_name: "Joe",
    room: {
      name: "lobby",
      display_name: "Lobby",
      scopes: ["room.self.audio_mute", "room.self.audio_unmute"],
      meta: {}
    },
    signature: "SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q",
    media_allowed: "all",
    audio_allowed: "both",
    video_allowed: "both",
    meta: {}
  },
  protocol: "signalwire_SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q_03e8c927-8ea3-4661-86d5-778c3e03296a_8f0a119a-cda7-4497-a47d-c81493b824d4",
  ice_servers: [
    {
      urls: "turn.swire.io:443",
      credential: "sFTwvi8ShXcYNOcyYjFy3ATIUpQ=",
      //@ts-expect-error
      credentialType: "password",
      username: "1619521908:8f0a119a-cda7-4497-a47d-c81493b824d4"
    }
  ]
};
var createSwEventChannel = () => multicastChannel2();
var createSessionChannel = () => channel2();

// src/index.ts
var selectors = __spreadValues({}, sessionSelectors_exports);
export {
  AuthError,
  BaseClient,
  BaseComponent,
  BaseConsumer,
  BaseJWTSession,
  BaseSession,
  CapabilityError,
  chat_exports as Chat,
  ChatMember,
  ChatMessage,
  DEFAULT_CONNECT_VERSION,
  EventEmitter,
  FABRIC_MEMBER_UPDATABLE_PROPS,
  FABRIC_MEMBER_UPDATED_EVENTS,
  GLOBAL_VIDEO_EVENTS,
  HttpError,
  INTERNAL_FABRIC_MEMBER_UPDATABLE_PROPS,
  INTERNAL_FABRIC_MEMBER_UPDATED_EVENTS,
  INTERNAL_MEMBER_UPDATABLE_PROPS,
  INTERNAL_MEMBER_UPDATED_EVENTS,
  LOCAL_EVENT_PREFIX,
  MEMBER_UPDATABLE_PROPS,
  MEMBER_UPDATED_EVENTS,
  memberPosition_exports as MemberPosition,
  pubSub_exports as PubSub,
  PubSubMessage,
  RPCConnect,
  RPCDisconnectResponse,
  RPCEventAckResponse,
  RPCExecute,
  RPCPing,
  RPCPingResponse,
  RPCReauthenticate,
  rooms_exports as Rooms,
  SWCloseEvent,
  SYMBOL_CONNECT_ERROR,
  SYMBOL_EXECUTE_CONNECTION_CLOSED,
  SYMBOL_EXECUTE_TIMEOUT,
  UNIFIED_CONNECT_VERSION,
  VertoAnswer,
  VertoAttach,
  VertoBye,
  VertoInfo,
  VertoInvite,
  VertoModify,
  VertoPong,
  VertoResult,
  VertoSubscribe,
  WEBRTC_EVENT_TYPES,
  actions_exports as actions,
  asyncRetry,
  componentActions,
  componentReducer,
  componentSelectors_exports as componentSelectors,
  configureStore2 as configureStore,
  connect,
  constDelay,
  debounce,
  decreasingDelay,
  extendComponent,
  fromSnakeToCamelCase,
  getEventEmitter,
  getLogger,
  increasingDelay,
  initialComponentState,
  initialSessionState,
  isConnectRequest,
  isGlobalEvent,
  isJSONRPCRequest,
  isJSONRPCResponse,
  isSATAuth,
  isVertoInvite,
  isWebrtcEventType,
  makeRPCRequest,
  makeRPCResponse,
  sagaEffects,
  sagaHelpers_exports as sagaHelpers,
  selectors,
  sessionActions,
  sessionReducer,
  setLogger,
  stripNamespacePrefix,
  testUtils_exports as testUtils,
  timeoutPromise,
  toExternalJSON,
  toInternalAction,
  toInternalEventName,
  toLocalEvent,
  toSnakeCaseKeys,
  toSyntheticEvent,
  v4 as uuid,
  validateEventsToSubscribe
};
//# sourceMappingURL=index.esm.js.map
